head	1.11;
access;
symbols;
locks
	becker:1.11; strict;
comment	@ * @;


1.11
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.24.02.09.00;	author becker;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.06.00.38.36;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.02.00.14.44;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.01.01.25.28;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.24.01.02.13;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.23.01.06.56;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.20.23.44.20;	author becker;	state Exp;
branches;
next	;


desc
@@


1.11
log
@*** empty log message ***
@
text
@/* 


output routines of Hager & Connell code

$Id: hc_output.c,v 1.10 2004/12/20 05:18:12 becker Exp becker $


*/
#include "hc.h"
/* 


print the spherical harmonics version of a solution set


*/
void hc_print_spectral_solution(struct hcs *hc,struct sh_lms *sol,
				FILE *out,int sol_mode, 
				hc_boolean binary, 
				hc_boolean verbose)
{
  int nradp2,i,os;
  static int ntype = 3;			/* three sets of solutions, r/pol/tor */
  HC_PREC fac[3];
  if(!hc->spectral_solution_computed)
    HC_ERROR("hc_print_spectral_solution","spectral solution not computed");
  /* 
     number of solution sets of ntype solutions 
  */
  nradp2 = hc->nrad+2;
  hc_compute_solution_scaling_factors(hc,sol_mode,fac);
  for(i=os=0;i < nradp2;i++,os += ntype){
    /* 
       write parameters, convert radius to depth in [km]  
    */
    sh_print_parameters((sol+os),ntype,i,nradp2,
			HC_Z_DEPTH(hc->r[i]),
			out,FALSE,binary,verbose);
    /* 
       
       write the set of coefficients in D&T convention
       
    */
    sh_print_coefficients((sol+os),ntype,out,fac,binary,verbose);
    if(verbose >= 2)
      fprintf(stderr,"hc_print_spectral_solution: z: %8.3f |r|: %11.3e |pol|: %11.3e |tor|: %11.3e (scale: %g cm/yr)\n",
	      HC_Z_DEPTH(hc->r[i]),sqrt(sh_total_power((sol+os))),
	      sqrt(sh_total_power((sol+os+1))),
	      sqrt(sh_total_power((sol+os+2))),
	      fac[0]/8.99321605918731);
  }
  if(verbose)
    fprintf(stderr,"hc_print_spectral_solution: wrote solution at %i levels\n",
	    nradp2);
}
/* 

print the spatial solution in 

lon lat vr vt vp 

format to nrad+2 files named filename.i.pre, where i is 0...nrad+1,
and pre is dat or bin, depending on ASCII or binary output.

will also write the corresponding depth layers to dfilename

*/
void hc_print_spatial_solution(struct hcs *hc, struct sh_lms *sol,
			       float *sol_x, char *name, 
			       char *dfilename, 
			       int sol_mode, hc_boolean binary, 
			       hc_boolean verbose)
{
  int nradp2,i,j,k,os[3],los,np,np2,np3;
  FILE *file_dummy=NULL,*out,*dout;
  float flt_dummy=0,*xy=NULL,value[3];
  HC_PREC fac[3];
  char filename[300];
  if(!hc->spatial_solution_computed)
    HC_ERROR("hc_print_spatial_solution","spectral solution not computed");
  /* number of solution sets of ntype solutions */
  nradp2 = hc->nrad+2;
  /* number of lateral points */
  np = sol[0].npoints;
  np2 = np*2;
  np3 = np*3;
  if(!np)
    HC_ERROR("hc_print_spatial_solution","npoints is zero");
  /* 
     compute the lateral coordinates
  */
  sh_compute_spatial_basis(sol, file_dummy, FALSE,flt_dummy, &xy,
			   1,verbose);
  /* 
     compute the scaling factors 
  */
  hc_compute_solution_scaling_factors(hc,sol_mode,fac);
  /* depth file */
  dout = hc_open(dfilename,"w","hc_print_spatial_solution");
  for(i=0;i < nradp2;i++){
    /* write depth in [km] to dout file */
    fprintf(dout,"%g\n",HC_Z_DEPTH(hc->r[i]));
    for(k=0;k < 3;k++)		/* pointers */
      os[k] = i * np3 + k*np;
    if(binary){
      sprintf(filename,"%s.%i.bin",name,i+1);
      out = hc_open(filename,"w","hc_print_spatial_solution");
      for(j=los=0;j < np;j++,los+=2){ /* loop through all points in layer */
	fwrite((xy+los),sizeof(float),2,out);
	for(k=0;k<3;k++)
	  value[k] = sol_x[os[k]] * fac[k];
	fwrite(value,sizeof(float),3,out);
	os[0]++;os[1]++;os[2]++;
      }     
      fclose(out);
    }else{
      sprintf(filename,"%s.%i.dat",name,i+1);
      out = hc_open(filename,"w","hc_print_spatial_solution");
      for(j=los=0;j < np;j++,los+=2){ /* loop through all points in layer */
	for(k=0;k<3;k++)
	  value[k] = sol_x[os[k]] * fac[k];
	fprintf(out,"%11g %11g\t%12.5e %12.5e %12.5e\n",
		xy[los],xy[los+1],value[0],value[1],value[2]);
	os[0]++;os[1]++;os[2]++;
      }
      fclose(out);
    }
    if(verbose >= 2)
      fprintf(stderr,"hc_print_spatial_solution: layer %3i: RMS: r: %12.5e t: %12.5e p: %12.5e file: %s\n",
	      i+1,hc_svec_rms((sol_x+i*np3),np),hc_svec_rms((sol_x+i*np3+np),np),
	      hc_svec_rms((sol_x+i*np3+np2),np),
	      filename);
  }
  fclose(dout);
  if(verbose)
    fprintf(stderr,"hc_print_spatial_solution: wrote solution at %i levels\n",
	    nradp2);
  free(xy);
}

/* 

print the depth layers solution

*/
void hc_print_depth_layers(struct hcs *hc, FILE *out, 
			   hc_boolean verbose)
{
  int nradp2,i;
  /* number of solution sets of ntype solutions */
  nradp2 = hc->nrad + 2;
  for(i=0;i < nradp2;i++)
    fprintf(out,"%g\n",HC_Z_DEPTH(hc->r[i]));
}


/* 

print a [3][3] matrix

*/
void hc_print_3x3(HC_PREC a[3][3], FILE *out)
  {
  int i,j;
  for(i=0;i<3;i++){
    for(j=0;j<3;j++)
      fprintf(out,"%11.4e ",a[i][j]);
    fprintf(out,"\n");
  }
}
/* 

print a [6][4] solution matrix

*/
void hc_print_sm(HC_PREC a[6][4], FILE *out)
{
  int i,j;
  for(i=0;i < 6;i++){
    for(j=0;j<4;j++)
      fprintf(out,"%11.4e ",a[i][j]);
    fprintf(out,"\n");
  }
}

void hc_print_vector(HC_PREC *a, int n,FILE *out)
{
  int i;
  for(i=0;i<n;i++)
    fprintf(out,"%11.4e ",a[i]);
  fprintf(out,"\n");
}


void hc_print_vector_row(HC_PREC *a, int n,FILE *out)
{
  int i;
  for(i=0;i<n;i++)
    fprintf(out,"%11.4e\n",a[i]);
}

/* 
   compute the r, theta, phi fac[3] scaling factors for the solution output 
*/
void hc_compute_solution_scaling_factors(struct hcs *hc,int sol_mode,HC_PREC *fac)
{

 switch(sol_mode){
  case HC_VEL:
    fac[0]=fac[1]=fac[2] = 1.0/hc->vel_scale; /* go to cm/yr  */
    break;
  case HC_STRESS:
    fac[0]=fac[1]=fac[2] = 1.0; /* go to ??? */
    break;
  case HC_GEOID:
    fac[0]=fac[1]=fac[2] = 1.0; /* go to ??? */
    break;
  default:
    HC_ERROR("hc_print_spectral_solution","mode undefined");
    break;
  }

}
/* 
   
output of poloidal solution up to l_max

 */
void hc_print_poloidal_solution(struct sh_lms *pol_sol,
				struct hcs *hc,
				int l_max, char *filename,
				hc_boolean verbose)
{
  int l,m,i,j,a_or_b,ll,nl,os;
  FILE *out;
  HC_PREC value[2];
  /* 
     output of poloidal solution vectors in internal convention
  */
  if(verbose)
    fprintf(stderr,"hc_print_poloidal_solution: printing poloidal colution vector to %s\n",
	    filename);
  /* find max output degree */
  ll = HC_MIN(l_max,pol_sol[0].lmax);
  /* number of output layers */
  nl = hc->nrad + 2;
  
  out = hc_open(filename,"w","hc_print_poloidal_solution");
  for(l=1;l <= ll;l++){
    for(m=0;m <= l;m++){
      for(a_or_b=0;a_or_b < ((m==0)?(1):(2));a_or_b++){
	for(i=os=0;i < nl;i++,os+=6){
	  fprintf(out,"%3i %3i %1i %3i %8.5f ",l,m,a_or_b,i+1,
		  hc->r[i]);
	  for(j=0;j < 6;j++){
	    sh_get_coeff((pol_sol+os+j),l,m,a_or_b,FALSE,value);
	    fprintf(out,"%11.4e ",value[0]);
	  } /* end u_1 .. u_4 nu_1 nu_2 loop */
	  fprintf(out,"\n");
	} /* end layer loop */
      } /* and A/B coefficient loop */
    }	/* end m loop */
  } /* end l loop */
  fclose(out);
}

/* 
   print toroidal solution vector (kernel), not expansion
*/
void hc_print_toroidal_solution(double *tvec,int lmax,
				struct hcs *hc,int l_max_out, 
				char *filename,
				hc_boolean verbose)
{
  FILE *out;
  int ll,l,i,nl,lmaxp1,os,os2;
  ll = HC_MIN(l_max_out,lmax); /* output lmax */
  nl = hc->nrad + 2;		/* number of layers */
  lmaxp1 = lmax + 1;		/* max expansion */
  os2 = lmaxp1 * nl;
  /* 
     kernel output
  */
  if(verbose)
    fprintf(stderr,"hc_print_toiroidal_solution: writing toroidal solutions 1 and 2 as f(l,r) to %s\n",
	    filename);
  out = hc_open(filename,"w","hc_toroidal_solution");
  for(l=1;l <= ll;l++){
    for(os=i=0;i < nl;i++,os+=lmaxp1)
      fprintf(out,"%3i %16.7e %16.7e %16.7e\n",
	      l,hc->r[i],tvec[os+l],tvec[os2+os+l]);
    fprintf(out,"\n");
  }
  fclose(out);
}
@


1.10
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.9 2004/12/20 05:09:42 becker Exp becker $
d23 1
a23 1
  int nradp2,i,j,os;
a24 1
  float zlabel;
d76 2
a77 3
  static int ntype = 3;			/* three sets of solutions, r/pol/tor */
  FILE *file_dummy,*out,*dout;
  float zlabel,flt_dummy,*xy=NULL,value[3],z;
d189 1
a189 1
  int i,j;
d198 1
a198 1
  int i,j;
@


1.9
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.8 2004/12/01 01:25:35 becker Exp becker $
d26 1
a26 1
  HC_CPREC fac[3];
d80 1
a80 1
  HC_CPREC fac[3];
d165 1
a165 1
void hc_print_3x3(HC_CPREC a[3][3], FILE *out)
d179 1
a179 1
void hc_print_sm(HC_CPREC a[6][4], FILE *out)
d189 1
a189 1
void hc_print_vector(HC_CPREC *a, int n,FILE *out)
d198 1
a198 1
void hc_print_vector_row(HC_CPREC *a, int n,FILE *out)
d208 1
a208 1
void hc_compute_solution_scaling_factors(struct hcs *hc,int sol_mode,HC_CPREC *fac)
d239 1
a239 1
  HC_CPREC value[2];
@


1.8
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.7 2004/11/24 02:09:00 becker Exp becker $
d18 1
a18 1
void hc_print_spectral_solution(struct hcs *hc,struct lms *sol,
d70 1
a70 1
void hc_print_spatial_solution(struct hcs *hc, struct lms *sol,
d232 1
a232 1
void hc_print_poloidal_solution(struct lms *pol_sol,
@


1.7
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.6 2004/08/06 00:38:36 becker Exp becker $
d26 1
a26 1
  CPREC fac[3];
d42 3
a44 1
       write the set of coefficients 
d47 1
a47 1
    if(verbose)
d49 2
a50 1
	      HC_Z_DEPTH(hc->r[i]),sqrt(sh_total_power((sol+os))),sqrt(sh_total_power((sol+os+1))),
d80 1
a80 1
  CPREC fac[3];
d109 1
a109 1
      sprintf(filename,"%s.%i.bin",name,i);
d120 1
a120 1
      sprintf(filename,"%s.%i.dat",name,i);
d131 1
a131 1
    if(verbose)
d165 1
a165 1
void hc_print_3x3(CPREC a[3][3], FILE *out)
d179 1
a179 1
void hc_print_sm(CPREC a[6][4], FILE *out)
d189 1
a189 1
void hc_print_vector(CPREC *a, int n,FILE *out)
d198 1
a198 1
void hc_print_vector_row(CPREC *a, int n,FILE *out)
d208 1
a208 1
void hc_compute_solution_scaling_factors(struct hcs *hc,int sol_mode,CPREC *fac)
d227 72
@


1.6
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.5 2004/07/02 00:14:44 becker Exp becker $
d47 2
a48 2
	      HC_Z_DEPTH(hc->r[i]),sqrt(sh_power((sol+os))),sqrt(sh_power((sol+os+1))),
	      sqrt(sh_power((sol+os+2))),
d57 8
a64 1
print the spatial solution
d68 2
a69 1
			       float *sol_x, FILE *out, 
d75 1
a75 1
  FILE *file_dummy;
d78 1
d98 2
d101 2
a104 1
    z = HC_Z_DEPTH(hc->r[i]);
d106 2
a109 1
	fwrite(&z,sizeof(float),1,out);
d115 1
d117 2
d122 2
a123 2
	fprintf(out,"%11g %11g %11g\t%12.5e %12.5e %12.5e\n",
		xy[los],xy[los+1],z,value[0],value[1],value[2]);
d125 2
a126 1
      }     
d129 1
a129 1
      fprintf(stderr,"hc_print_spatial_solution: layer %3i: RMS: r: %12.5e t: %12.5e p: %12.5e\n",
d131 2
a132 3
	      hc_svec_rms((sol_x+i*np3+np2),np));
    
    
d134 1
@


1.5
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.4 2004/07/01 01:25:28 becker Exp becker $
d18 4
a21 3
void hc_print_sh_solution(struct hcs *hc,struct lms *sol, FILE *out,
			  int sol_mode,
			  hc_boolean binary, hc_boolean verbose)
d23 2
a24 1
  int nset,shps,i,os;
d27 8
a34 17
  shps = 3;			/* three sets of solutions, r/pol/tor */
  nset = hc->nrad+2;
  switch(sol_mode){
  case HC_VEL:
    fac[0]=fac[1]=fac[2] = 1.0/hc->vel_scale; /* go to cm/yr  */
    break;
  case HC_STRESS:
    fac[0]=fac[1]=fac[2] = 1.0; /* go to ??? */
    break;
  case HC_GEOID:
    fac[0]=fac[1]=fac[2] = 1.0; /* go to ??? */
    break;
  default:
    HC_ERROR("hc_print_sh_solution","mode undefined");
    break;
  }
  for(i=os=0;i<nset;i++,os+=shps){
d38 2
a39 1
    sh_print_parameters((sol+os),shps,i,nset,HC_Z_DEPTH(hc->r[i]),
d44 1
a44 1
    sh_print_coefficients((sol+os),shps,out,fac,binary,verbose);
d46 1
a46 1
      fprintf(stderr,"hc_print_sh_solution: z: %8.3f |r|: %11.3e |pol|: %11.3e |tor|: %11.3e (scale: %g cm/yr)\n",
d52 85
a136 2
    fprintf(stderr,"hc_print_sh_solution: wrote solution at %i levels\n",
	    nset);
d146 1
a146 1
{
d185 5
d191 16
@


1.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.3 2004/06/24 01:02:13 becker Exp becker $
d20 1
a20 1
			  my_boolean binary, my_boolean verbose)
d38 1
a38 1
    MY_ERROR("hc_print_sh_solution","mode undefined");
d55 1
a55 1
	      fac[0]/10.0);
@


1.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.2 2004/06/23 01:06:56 becker Exp becker $
d11 1
d14 1
a15 1
/* 
d17 1
a17 3
print the spherical harmonics version of a solution set

 */
d19 1
d24 1
d27 14
d50 1
a50 1
    sh_print_coefficients((sol+os),shps,out,binary,verbose);
d52 1
a52 1
      fprintf(stderr,"hc_print_sh_solution: z: %8.3f |r|: %12.5e |pol|: %12.5e |tor|: %12.5e\n",
d54 2
a55 1
	      sqrt(sh_power((sol+os+2))));
d85 1
a85 1
  for(i=0;i<6;i++){
@


1.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
$Id: hc_output.c,v 1.1 2004/06/20 23:44:20 becker Exp becker $
d19 2
a20 2
void hc_print_sh_solution(struct hcs *hc,struct lms *sol,
			  char *filename, my_boolean verbose)
a23 1
  FILE *out;
a25 1
  out = myopen(filename,"w","hc_print_sh_solution");
d27 3
a29 1
    /* write parameters, convert radius to depth in [km]  */
d31 9
a39 3
			out,verbose);
    /* write the set of coefficients */
    sh_print_coefficients((sol+os),shps,out,verbose);
a40 1
  fclose(out);
d42 2
a43 2
    fprintf(stderr,"hc_print_sh_solution: wrote solution at %i levels to file %s\n",
	    nset,filename);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
$Id$
d40 48
@
