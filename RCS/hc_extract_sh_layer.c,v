head	1.9;
access;
symbols;
locks
	becker:1.9; strict;
comment	@ * @;


1.9
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.24.02.09.00;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.06.00.38.36;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.02.00.14.44;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.01.01.25.28;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.24.01.02.13;	author becker;	state Exp;
branches;
next	;


desc
@@


1.9
log
@*** empty log message ***
@
text
@#include "hc.h"
/* 


extract part of a spherical harmonics solution of a HC run


$Id: hc_extract_sh_layer.c,v 1.8 2004/12/20 05:18:12 becker Exp becker $


*/

int main(int argc, char **argv)
{
  int ilayer,nradp2,nsol,i,radial,shps,nset=1;
  FILE *in;
  struct sh_lms *sol=NULL;
  struct hcs *model;
  HC_PREC fac[3] = {1.0,1.0,1.0};
  hc_boolean binary = TRUE, verbose = FALSE, short_format = FALSE;
  hc_struc_init(&model);
  /* 
     deal with parameters
  */
  ilayer = 0;
  radial = 0;
  switch(argc){
  case 3:
    sscanf(argv[2],"%i",&ilayer);
    break;
  case 4:
    sscanf(argv[2],"%i",&ilayer);
    sscanf(argv[3],"%i",&radial);
    break;
  case 5:
    sscanf(argv[2],"%i",&ilayer);
    sscanf(argv[3],"%i",&radial);
    sscanf(argv[4],"%i",&i);
    if(i)
      short_format = TRUE;
    else
      short_format = FALSE;
    break;
  default:
    fprintf(stderr,"%s: usage\n%s sol.file layer [radial] [short_format, %i]\n\n",
	    argv[0],argv[0],short_format);
    fprintf(stderr,"extracts spherical harmonic solution from HC run\n");
    fprintf(stderr,"layer should be 1...nset\n");
    fprintf(stderr,"if ilayer=-1, will select nset\n\n");
    exit(-1);
    break;
  }
  /* 
     read in solution
  */
  in = hc_open(argv[1],"r","hc_extract_sh_layer");
  hc_read_sh_solution(model,&sol,in,binary,verbose);
  fclose(in);
  nradp2 = model->nrad+2;
  nsol = nradp2 * 3;
  /* 
     deal with selection
  */
  if(ilayer == -1)
    ilayer = nradp2;
  if((ilayer<1)||(ilayer > nradp2)){
    fprintf(stderr,"%s: ilayer (%i) out of range, use 1 ... %i\n",
	    argv[0],ilayer,nradp2);
    exit(-1);
  }
  ilayer--;
  /* 
     output 
  */
  shps = (radial)?(1):(2);
  sh_print_parameters((sol+ilayer*3),shps,
		      ilayer,nset,(HC_PREC)(HC_Z_DEPTH(model->r[ilayer])),
		      stdout,short_format,FALSE,verbose);
  if(radial){
    if(verbose)
      fprintf(stderr,"%s: printing u_r SHE at layer %i (depth: %g)\n",
	      argv[0],ilayer,HC_Z_DEPTH(model->r[ilayer]));
    sh_print_coefficients((sol+ilayer*3),shps,stdout,fac,FALSE,verbose);
  }else{
    if(verbose)
      fprintf(stderr,"%s: printing u_pol u_tor SHE at layer %i (depth: %g)\n",
	      argv[0],ilayer,HC_Z_DEPTH(model->r[ilayer]));
    sh_print_coefficients((sol+ilayer*3+1),shps,stdout,fac,FALSE,verbose);
  }
  /* clear and exit */
  sh_free_expansion(sol,nsol);

  return 0;
}
@


1.8
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.7 2004/12/20 05:09:42 becker Exp becker $
d92 1
a92 1
  free(model);
@


1.7
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.6 2004/12/01 01:25:35 becker Exp becker $
d19 1
a19 1
  HC_CPREC fac[3] = {1.0,1.0,1.0};
d77 1
a77 1
		      ilayer,nset,(HC_CPREC)(HC_Z_DEPTH(model->r[ilayer])),
@


1.6
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.5 2004/11/24 02:09:00 becker Exp becker $
d17 1
a17 1
  struct lms *sol=NULL;
@


1.5
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.4 2004/08/06 00:38:36 becker Exp becker $
d19 1
a19 1
  CPREC fac[3] = {1.0,1.0,1.0};
d48 2
a49 1
    fprintf(stderr,"layer should be 0...nset-1\n\n");
d65 4
a68 4
    ilayer = nradp2-1;
  if((ilayer<0)||(ilayer > nradp2-1)){
    fprintf(stderr,"%s: ilayer (%i) out of range, use 0...%i\n",
	    argv[0],ilayer,nradp2-1);
d71 1
d77 1
a77 1
		      ilayer,nset,(CPREC)(HC_Z_DEPTH(model->r[ilayer])),
d91 1
a91 2
  for(i=0;i<nsol;i++)
    sh_free_expansion((sol+i));
@


1.4
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.3 2004/07/02 00:14:44 becker Exp becker $
d20 1
a20 1
  hc_boolean binary = TRUE, verbose = TRUE, short_format = FALSE;
@


1.3
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.2 2004/07/01 01:25:28 becker Exp becker $
d15 1
a15 1
  int ilayer,nradp2,nsol,i,radial;
d20 1
a20 1
  hc_boolean binary = TRUE, verbose = TRUE;
d35 9
d45 4
a48 2
    fprintf(stderr,"%s: usage\n%s sol.file layer [radial]\n\n",argv[0],argv[0]);
    fprintf(stderr,"extracts spherical harmonic solution from HC run\n\n");
d68 1
d73 4
a76 1
  fprintf(stdout,"%i\n",sol[0].lmax);
d81 1
a81 1
    sh_print_coefficients((sol+ilayer*3),1,stdout,fac,FALSE,verbose);
d86 1
a86 1
    sh_print_coefficients((sol+ilayer*3+1),2,stdout,fac,FALSE,verbose);
@


1.2
log
@*** empty log message ***
@
text
@d8 1
a8 1
$Id: hc_extract_sh_layer.c,v 1.1 2004/06/24 01:02:13 becker Exp becker $
d20 1
a20 1
  my_boolean binary = TRUE, verbose = TRUE;
d44 1
a44 1
  in = myopen(argv[1],"r","hc_extract_sh_layer");
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
$Id$
d15 1
a15 1
  int ilayer,nradp2,nsol,i;
d19 2
a20 1
  my_boolean binary = TRUE, verbose = TRUE, print_radial = FALSE;
d25 2
d31 4
d36 1
a36 1
    fprintf(stderr,"%s: usage\n%s sol.file layer\n\n",argv[0],argv[0]);
d62 1
a62 1
  if(print_radial){
d66 1
a66 1
    sh_print_coefficients((sol+ilayer*3),1,stdout,FALSE,verbose);
d71 1
a71 1
    sh_print_coefficients((sol+ilayer*3+1),2,stdout,FALSE,verbose);
@
