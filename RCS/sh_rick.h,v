head	1.3;
access;
symbols;
locks
	becker:1.3; strict;
comment	@ * @;


1.3
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.20.05.09.57;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.00.36.28;	author becker;	state Exp;
branches;
next	;


desc
@@


1.3
log
@*** empty log message ***
@
text
@ /* 

factor by which to multiply Rick's internal AB coefficients to
physical convention, real spherical haronics coefficients as in Dahlen
and Tromp


*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifndef TWOPI
#define TWOPI 6.283185307179586476925286766559005768394
#endif

#define SH_RICK_TWO_SQRT_PI 3.54490770181103
#define SH_RICK_TWO_SQRT_TWO_PI 5.013256549262

// 
// this would give the internal normalization as used in the original flow
// code
//
//#define SH_RICK_FACTOR(l, m) ((m==0)?(SH_RICK_TWO_SQRT_PI):(pow(-1.0,(double)(m))*SH_RICK_TWO_SQRT_PI))
#define SH_RICK_FACTOR(l, m) ((m==0)?(SH_RICK_TWO_SQRT_PI):(pow(-1.0,(double)(m))*SH_RICK_TWO_SQRT_TWO_PI))
//

#ifdef SH_RICK_DOUBLE_PRECISION
#define SH_RICK_PREC double
#define rick_vecalloc hc_dvecalloc
#else
#define SH_RICK_PREC float
#define rick_vecalloc hc_svecalloc
#endif

#ifndef my_boolean
#define my_boolean unsigned short 
#endif
#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif


struct rick_module{
  // read the defines for single/double precision
  // other stuff needed by more than one subroutine
  // Gauss points: cos(theta), weights, and actual theta
  SH_RICK_PREC  *gauss_z, *gauss_w, *gauss_theta;
  SH_RICK_PREC *lfac, *ilfac;
  // those are for Legendre polynomials (fac1  fac2 only for ivec=1)
  // make those double precision
  //
  double  *plm_f1,*plm_f2,*plm_fac1,*plm_fac2,*plm_srt;
  // this is for vector harmonics, only for ivec=1
  SH_RICK_PREC  *sin_theta,*ell_factor;
  // spacing in longitudes
  double dphi;
  // int (bounds and such)
  int nlat,nlon,lmsize,lmsize2,nlonm1;
  // logic flags
  my_boolean initialized,computed_legendre,
    vector_sh_fac_init;
};

/* 


C declarations for F90 functions from Rick's 
spherical harmonics routines


*/

#ifdef LINUX_SUBROUTINE_CONVENTION
#define rick_f90_shd2c rick_f90_shd2c_
#define rick_f90_shd2c_pre rick_f90_shd2c_pre_
#define rick_f90_shc2d rick_f90_shc2d_
#define rick_f90_shc2d_pre rick_f90_shc2d_pre_
#define rick_f90_init rick_f90_init_
#define rick_f90_pix2ang rick_f90_pix2ang_
#define rick_f90_free_module rick_f90_free_module_
#define rick_f90_index rick_f90_index_
#define rick_f90_compute_allplm rick_f90_compute_allplm_
#define rick_f90_ab2cs  rick_f90_ab2cs_
#define rick_f90_cs2ab  rick_f90_cs2ab_
#define rick_f90_realft rick_f90_realft_
#endif

/* 

f90 versions

*/

extern void rick_f90_shd2c(float *,float *,int *,int *, 
			   SH_RICK_PREC *,SH_RICK_PREC *);
extern void rick_f90_shd2c_pre(float *, float *,int *,double *,
			   double *, int *,SH_RICK_PREC *,
			   SH_RICK_PREC *);
extern void rick_f90_shc2d(SH_RICK_PREC *,SH_RICK_PREC *,int *,int *, 
		       float *, float *);
extern void rick_f90_shc2d_pre(SH_RICK_PREC *,SH_RICK_PREC *,
			   int *,double *,
			   double *,int *,float *,float *);
extern void rick_f90_init(int *,int *,int *,int *, int *);
extern void rick_f90_pix2ang(int *, int *, double *, double *);
extern void rick_f90_free_module(int *);
extern void rick_f90_index(int *,int *,int *,int *);
extern void rick_f90_compute_allplm(int *,int *,double *,double *);

/* FFT stuff */
extern void rick_f90_cs2ab( SH_RICK_PREC *, int *);
extern void rick_f90_ab2cs( SH_RICK_PREC *, int *);
extern void rick_f90_realft(SH_RICK_PREC *,int *,int *);
@


1.2
log
@*** empty log message ***
@
text
@d10 1
d30 1
d33 1
d51 2
a52 2
  double  *gauss_z, *gauss_w, *gauss_theta;
  double *lfac, *ilfac;
d87 3
d113 5
@


1.1
log
@Initial revision
@
text
@a11 3
#ifndef PI
#define PI 3.141592653589793238462643383279502884197
#endif
d16 3
a18 2
#define SH_RICK_SQRT_TWO_PI 2.5066282746310005
#define SH_RICK_TWO_SQRT_PI 3.5449077018110321
d23 2
a24 3
#define SH_RICK_FACTOR(l, m) ((m==0)?(SH_RICK_TWO_SQRT_PI):(pow(-1.0,(double)(-m))*2.0*SH_RICK_SQRT_TWO_PI))
//
// this version is derived from the formula from abconvet ...?
a25 2
//#define RICK_FACTOR(l, m) ((m==0)?(RICK_TWO_SQRT_PI):(pow(-1.0,(double)(-m))*RICK_SQRT_TWO_PI))

a83 1
#define rick_f90_compute_power rick_f90_compute_power_
a106 3
extern void rick_f90_compute_power(SH_RICK_PREC *,int *,
				   SH_RICK_PREC *);

@
