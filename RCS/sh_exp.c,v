head	1.15;
access;
symbols;
locks
	becker:1.15; strict;
comment	@ * @;


1.15
date	2006.03.20.05.32.48;	author becker;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.24.02.09.00;	author becker;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.23.19.24;	author becker;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.06.00.38.36;	author becker;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.30.23.52.04;	author becker;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.02.00.14.44;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.01.01.25.28;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.24.01.02.13;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.23.01.06.56;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.21.01.16.31;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.16.02.06.33;	author becker;	state Exp;
branches;
next	;


desc
@@


1.15
log
@*** empty log message ***
@
text
@/* 


lower level routines to handle spherical harmonics expansions

the higher level routines that operate on single (or triple) 
sets of expansions are in sh_model.c

$Id: sh_exp.c,v 1.14 2006/01/22 01:11:34 becker Exp becker $

*/
#include "hc.h"
/* 

allocates and initializes spherical harmonics structure

*/
void sh_allocate_and_init(struct sh_lms **exp, int n,int lmax, 
			  int type, int ivec, hc_boolean verbose)
{
  int i;
  /* init as zeroes! */
  *exp = (struct sh_lms *)calloc(n,sizeof(struct sh_lms));
  if(!(*exp))
    HC_MEMERROR("sh_allocate_and_init");
  for(i=0;i<n;i++){
    sh_init_expansion((*exp+i),lmax,type,ivec,verbose);
  }
}

/* 

compute the parameters needed for a single expansion of order lmax and
allocate initial array for spectral coefficients. the type of array
depends on the type of expansion. 

if you want vector harmonics at any point during a computation, set
ivec to unity initially

coefficients are initialized as zero


*/
void sh_init_expansion(struct sh_lms *exp, int lmax, int type, 
		       int ivec, hc_boolean verbose)
{
  /* 
     initialize logic flags 
  */
  exp->spectral_init = FALSE;
  /* type of expansion, e.g. SH_HEALPIX or SH_RICK, this will be checked later */
  exp->type = type;
#ifdef DEBUG
  /* 
     l and m bounds 
  */
  if(lmax < 1){
    fprintf(stderr,"sh_init_expansion: error: lmax out of bounds: %i\n",
	    lmax);
    exit(-1);
  }
#endif
  exp->lmax = lmax;
  /* same as above, plus one */
  exp->lmaxp1 = exp->lmax+1;
  /* 
     size of one set of coefficients (l,m) if stored by wasting space
     (assuming we are using complex numbers)
  */
  exp->lmbig = exp->lmaxp1 * exp->lmaxp1;
  /* 
     size of coefficients when stored compactly like 
     (l+1)*l/2 + m, times two for A and B
  */
  exp->lmsmall2 = (exp->lmaxp1)*(exp->lmaxp1+1); /* for A and B */

  /* 

  allocate the spectral (coefficients) storage and initialize possibly
  other arrays

  */
  switch(exp->type){
  case SH_HEALPIX:			/* SH_HEALPIX part */
    /* 
       
       get single precision complex array which holds A and B 
       
    */
    exp->n_lm = exp->lmbig;
    hc_scmplx_vecalloc(&exp->alm_c,exp->n_lm,"init_expansion");
    sh_clear_alm(exp);
    /* 
       init the Healpix parameters and determine the number of points
       in the spatial domain
    */
    heal_init_parameters(&exp->heal,(lmax/2)+2,SH_HEALPIX_RING,
			 ivec,exp->lmax,&exp->npoints,
			 &exp->n_plm,&exp->tn_plm);

    break;
  case SH_RICK:			/* SH_RICK PART */
    /* 
       make room for the coefficients A and B in compact storage
    */
    exp->n_lm = exp->lmsmall2;
    /* 
       use single precision vector 
    */
#ifdef SH_RICK_DOUBLE_PRECISION
    hc_dvecalloc(&exp->alm,exp->n_lm,"sh_init_expansion");
#else
    hc_svecalloc(&exp->alm,exp->n_lm,"sh_init_expansion");
#endif
    sh_clear_alm(exp);
    /* 
       
    init the parameters for Rick subroutines

    */
#ifdef NO_RICK_FORTRAN
    rick_init(exp->lmax,ivec,&exp->npoints,
	      &exp->n_plm,&exp->tn_plm,&exp->rick);
#else
    /* f90 version */
    rick_f90_init(&exp->lmax,&ivec,&exp->npoints,
		  &exp->n_plm,&exp->tn_plm);
#endif
    break;
  default:
    sh_exp_type_error("sh_init_expansion",exp);
    break;
  }
}
/* 
   free an expansion structure with n elements
*/
void sh_free_expansion(struct sh_lms *exp, int n)
{
  int i;
  for(i=0;i<n;i++){
    switch(exp[i].type){
    case SH_HEALPIX:			/* SH_HEALPIX part */
      heal_free_structure(&exp[i].heal);
      free(exp[i].alm_c);
      break;
    case SH_RICK:
      free(exp[i].alm);
      break;
    default:
      sh_exp_type_error("sh_free_expansion",(exp+i));
      break;
    }
  }
}
/* 
   zero out all coefficients
*/
void sh_clear_alm(struct sh_lms *exp)
{
  int i;
  switch(exp->type){
  case SH_HEALPIX:
    /* init with zeroes */
    for(i=0;i<exp->n_lm;i++)
      exp->alm_c[i].dr = exp->alm_c[i].di = 0.0;
    break;
  case SH_RICK:
    for(i=0;i<exp->n_lm;i++)
      exp->alm[i] = 0.0;
    break;
  default:
    sh_exp_type_error("sh_clear_alm",exp);
    break;
  }
}
/* 

compute | \Psi | ^2 = \sum (2l+1) \sigma^2

kindof RMS^2

*/
HC_CPREC sh_total_power(struct sh_lms *exp)
{
  float *power,sum;
  int l;
  hc_svecalloc(&power,exp->lmaxp1,"sh_total_power");
  sh_compute_power_per_degree(exp,power);
  for(sum=0.0,l=0;l<=exp->lmax;l++)
    sum += (2.0*(HC_CPREC)l+1.0) * power[l];
  free(power);
  return (HC_CPREC)sum;
}
/* 

compute the power (sigma^2) per degree and unit area

power[lmaxp1]

*/
void sh_compute_power_per_degree(struct sh_lms *exp, 
				 float *power)
{
  int l,m;
  HC_CPREC value[2];
  hc_boolean need_b;
  for(l=0;l<=exp->lmax;l++){
    power[l] = 0.0;
    for(m=0;m<=l;m++){
      need_b = (m == 0) ? 0 : 2;
      sh_get_coeff(exp,l,m,need_b,TRUE,value);
      power[l] += value[0] * value[0];
      if(need_b) 
	power[l] += value[1] * value[1];
    } /* end m loop */
    power[l] /= 2.0*((HC_CPREC)l)+1.0;
  } /* end l loop */
}

/* 

print one line with all parameters needed to identify a spherical
harmonics expansion for a scalar (shps == 1), poloidal/toroidal (shps
== 2), or a vector field (shps == 3)

exp[shps]

ilayer: the layer index (0...nset-1) for nset layers

zlabel: label for layer ilayer


if short_format is selected, will only print

lmax

*/
void sh_print_parameters(struct sh_lms *exp, int shps,
			 int ilayer, int nset,HC_CPREC zlabel,
			 FILE *out, hc_boolean short_format,
			 hc_boolean binary,hc_boolean verbose)
{
  HC_BIN_PREC fz;
  /* 
     print
     
     lmax i z[i] nset shps expansion_type
     
  */
  if(binary){
    fz = (HC_BIN_PREC)zlabel;
    fwrite(&exp[0].lmax,sizeof(int),1,out);
    if(!short_format){
      fwrite(&ilayer,sizeof(int),1,out);
      fwrite(&fz,sizeof(HC_BIN_PREC),1,out);
      fwrite(&nset,sizeof(int),1,out);
      fwrite(&shps,sizeof(int),1,out);
      fwrite(&exp[0].type,sizeof(int),1,out);
     }
  }else{
    if(!short_format)
      fprintf(out,"%6i %6i %11g %6i %2i %2i ",
	      exp[0].lmax,ilayer,zlabel,nset,
	      shps,exp[0].type);
    else
      fprintf(out,"%6i ",
	      exp[0].lmax);
  }
  /* 
     additional parameters? 
  */
  switch(exp[0].type){
  case SH_RICK:
  case SH_HEALPIX:
    break;
  default:
    sh_exp_type_error("sh_print_parameters",exp);
    break;
  }
  if(!binary)
    fprintf(out,"\n");		/* finish header line */
}
/* 
   
   read parameters needed to initialize an expansion
   can be used to read several layers of a model
   will return TRUE, if success
   
   default (long format) input is 

   type lmax shps ilayer nset zlabel ivec


   short format is just 

   lmax

   explanations:

   type: type of spherical harmonics expansion
   lmax: max degree
   shps: 1 or 3 for different sets of expansions, scalar or scalar + vector
   ilayer: 0..nset
   nset: number of sets
   zlabel: float label of this set
   ivec: scalar/vector flag. 0 for shps==1, 1 else
   
   
   
*/
hc_boolean sh_read_parameters(int *type, int *lmax, int *shps,
			      int *ilayer, int *nset,
			      HC_CPREC *zlabel,int *ivec,
			      FILE *in, hc_boolean short_format,
			      hc_boolean binary,hc_boolean verbose)
{
  int input1[2],input2[3];
  HC_BIN_PREC fz;
  double dtmp;
  /* 
     read
     
     lmax i+1 z[i] nset shps expansion_type
     
  */
  if(binary){
    if(short_format){
      if(fread(input1,sizeof(int),1,in) != 1)
	return FALSE;
      *lmax = input1[0]; 
    }else{
      if(fread(input1,sizeof(int),2,in)+
	 fread(&fz,   sizeof(HC_BIN_PREC),1,in) +
	 fread(input2,sizeof(int),3,in) != 6)
	return FALSE;
      *lmax = input1[0];    
      *ilayer=input1[1];
      *zlabel = (HC_CPREC) fz; 
      *nset = input2[0];
      *shps = input2[1];
      *type = input2[2];
    }
  }else{
    if(short_format){
      if(fscanf(in,"%i",lmax)!=1){
	return FALSE;
      }
    }else{
      if(fscanf(in,"%i %i %lf %i %i %i",
		lmax,ilayer,&dtmp,nset,shps,type)!=6){
	return FALSE;
      }
      *zlabel = (HC_CPREC)dtmp;
    }
  }
  if(short_format){
    /* default settings for short format */
    *zlabel = 0.0; *ilayer = 0; *nset=1;
    *shps = 1;     *type=SH_RICK;
  }
  if(*shps == 1)
    *ivec = 0;
  else
    *ivec = 1;
  /* 
     additional parameters? 
  */
  switch(*type){
  case SH_RICK:
  case SH_HEALPIX:
    break;
  default:
    fprintf(stderr,"sh_read_parameters: type %i undefined\n",
	    *type);
    exit(-1);
    break;
  }
  return TRUE;
}

/* 
   write the coefficients of a spherical harmonic expansion to out stream
   
   output will be real spherical harmonics coefficients as in Dahlen and
   Tromp p. 859
   
   for shps = 1
   
   A00 B00
   A10 B10
   A11 B11
   A20 ...

   for shps = 2

   A00_p B00_p    A00_t B00_t
   A10_p B10_p    A10_t B10_t
   ....
  

   for shps = 3

   A00_s B00_s   A00_p B00_p    A00_t B00_t
   A10_s B10_s   A10_p B10_p    A10_t B10_t
   ....
   
   where s, p, and t are the scalar (radial), poloidal, and toroidal expansions, 
   respectively


   pass shps as unity, if scalar, as 2 if pol/tor part of field, and
   as 3 if u_r pol tor components with three expansions for velocity
   field

   basically, all values of shps can be passed, as long as exp[shps]
   
   fac[3] scales the coefficients

*/
void sh_print_coefficients(struct sh_lms *exp, int shps, FILE *out, 
			   HC_CPREC *fac,hc_boolean binary, 
			   hc_boolean verbose)
{
  int j,l,m;
  HC_CPREC value[2];
  HC_BIN_PREC fvalue[2];
  /* 
     test  other expansions this set 
  */
  for(j=1;j < shps;j++){ /* check the lmax */
    if(exp[j].lmax != exp[0].lmax){
      fprintf(stderr,"sh_print_coefficients: error: lmax(%i):%i != lmax(0):%i\n",
	      j+1,exp[j].lmax,exp[0].lmax);
      exit(-1);
    }
    if(exp[j].type != exp[0].type ){
      fprintf(stderr,"sh_print_coefficients: error: type(%i):%i != type(0):%i\n",
	      j+1,exp[j].type,exp[0].type);
      exit(-1);
    }
  } /* end test */
  if(binary){
    for(l=0;l <= exp[0].lmax;l++)
      for(m=0;m <= l;m++)
	for(j=0;j < shps;j++){
	  /* output is in physical convention */
	  sh_get_coeff((exp+j),l,m,2,TRUE,value);
	  fvalue[0] = (HC_BIN_PREC)value[0]*fac[j];
	  fvalue[1] = (HC_BIN_PREC)value[1]*fac[j];
	  fwrite(fvalue,  sizeof(HC_BIN_PREC), 2, out);
	}
  }else{
    for(l=0;l <= exp[0].lmax;l++){
      for(m=0;m <= l;m++){
	for(j=0;j < shps;j++){
	  /* output in physical convention */
	  sh_get_coeff((exp+j),l,m,2,TRUE,value);
	  fprintf(out,"%15.7e %15.7e\t",value[0]*fac[j],value[1]*fac[j]);
	}
	fprintf(out,"\n");
      } /* end m loop */
    }	/* end l loop */
    fprintf(out,"\n");
  }
}
/* 

read in spherical harmonic coefficients in real, physics convention of
Dahlen and Tromp p. 859, and convert to whatever internal format may
be used

shps: number of spherical harmonics sets

scale coefficients with factor fac[shps]

lmax: -1: use lmax from expansion
       else: read up to lmax


*/
void sh_read_coefficients(struct sh_lms *exp, int shps, int lmax,
			  FILE *in, hc_boolean binary, HC_CPREC *fac,
			  hc_boolean verbose)
{
  int j,k,l,m,lmax_loc;
  HC_CPREC value[2]={0,0};
  HC_BIN_PREC fvalue[2]={0,0};
  if(lmax < 0)
    lmax_loc = exp[0].lmax;
  else
    lmax_loc = lmax;
  /* 
     test other expansions of this set 
  */
  for(j=1;j < shps;j++){ /* check the lmax */
    if(exp[j].lmax != exp[0].lmax){
      fprintf(stderr,"sh_read_coefficients: error: lmax(%i):%i != lmax(0):%i\n",
	      j+1,exp[j].lmax,exp[0].lmax);
      exit(-1);
    }
    if(exp[j].type != exp[0].type ){
      fprintf(stderr,"sh_read_coefficients: error: type(%i):%i != type(0):%i\n",
	      j+1,exp[j].type,exp[0].type);
      exit(-1);
    }
  } /* end test */
  if(binary){
    for(l=0;l <= lmax_loc;l++)
      for(m=0;m <= l;m++)
	for(j=0;j < shps;j++){
	  if(fread(fvalue, sizeof(HC_BIN_PREC),2,in)!=2){
	    fprintf(stderr,"sh_read_coefficients: read error: set %i l %i m %i\n",
		    j+1,l,m);
	    exit(-1);
	  }
	  for(k=0;k<2;k++)
	    value[k] = (HC_CPREC)fvalue[k];
	  /* read in real, Dahlen & Tromp normalized coefficients and convert
	     to whatever format we are using internally */
	  sh_write_coeff((exp+j),l,m,(m==0)?(0):(2),TRUE,value);
	}
  }else{
    for(l=0;l <= lmax_loc;l++)
      for(m=0;m <= l;m++)
	for(j=0;j < shps;j++){
	  if(fscanf(in,"%lf %lf",value,(value+1))!=2){
	    fprintf(stderr,"sh_read_coefficients: read error: set %i l %i m %i, last val: %g %g\n",
		    j+1,l,m,value[0],value[1]);
	    exit(-1);
	  }
	  /* read in real, Dahlen & Tromp normalized coefficients and convert
	     to whatever format we are using internally */
	  sh_write_coeff((exp+j),l,m,(m==0)?(0):(2),TRUE,value);
	}
  }
  /* fill up rest with zeroes, if we are limiting to lmax_loc */
  if(lmax_loc < exp[0].lmax){
    value[0] = value[1] = 0.0;
    for(l=lmax_loc+1;l <= exp[0].lmax;l++)
      for(m=0;m <= l;m++)
	for(j=0;j < shps;j++)
	  sh_write_coeff((exp+j),l,m,(m==0)?(0):(2),TRUE,value);
  }
  for(j=0;j < shps;j++){
    sh_scale_expansion((exp+j),fac[j]);
    exp[j].spectral_init = TRUE;
  }
}

/* 

given an initializez expansion structure, read the corresponding spatial data in 

lon lat data

format from FILE *in

the output is in the data array, which has to be passed 

data[shps * exp->npoints]

if use_3d is set, will read in 

lon lat z data

instead

*/
void sh_read_spatial_data(struct sh_lms *exp, FILE *in, 
			  my_boolean use_3d, 
			  int shps, float *data, float *z)
{
  double lon,lat,xp[3];
  int j,k;
  /* 
     read in data for each layer 
  */
  for(j=0;j < exp->npoints;j++){
    /* 
       get expected coordinates to check if the input is OK
    */
    switch(exp->type){
    case SH_HEALPIX:
      switch(exp->heal.ordering){
      case SH_HEALPIX_RING:  
	pix2ang_ring((long)exp->heal.nside,(long)j,
		     (xp+HC_THETA),(xp+HC_PHI));
	break;
      case SH_HEALPIX_NEST:  
	pix2ang_nest((long)exp->heal.nside,(long)j,
		     (xp+HC_THETA),(xp+HC_PHI));
	break;
      default:
	fprintf(stderr,"sh_read_spatial_data: error: ordering %i undefined\n",
		exp->heal.ordering);
	exit(-1);
	break;
      }
      break;			/* end Healpix branch */
    case SH_RICK:
      /* for Rick's type routine */
#ifdef NO_RICK_FORTRAN
      rick_pix2ang(j,exp->lmax,(xp+HC_THETA),(xp+HC_PHI),
		   &exp->rick);
#else
      rick_f90_pix2ang(&j,&exp->lmax,(xp+HC_THETA),(xp+HC_PHI));
#endif
      break;
    default:
      sh_exp_type_error("sh_read_model_spatial_data",exp);
      break;
    }	/* end type branch */
    /* 
       read coordinates 
    */
    if(!use_3d){
      /* 
	 read in lon lat  
      */
      if(fscanf(in,"%lf %lf",&lon,&lat) != 2){
	fprintf(stderr,"sh_read_spatial_data: error: lon lat format: pixel %i: read error\n",
		(int)j);
	exit(-1);
      }
    }else{
      /* 
	 read in lon lat z[i] 
      */
      if(fscanf(in,"%lf %lf %f",&lon,&lat,z) != 3){
	fprintf(stderr,"sh_read_spatial_data: error: lon lat z format: pixel %i: read error\n",
		(int)j);
	exit(-1);
      }
    }
    /* 
       read data 
    */
    for(k=0;k < shps;k++){
      if(fscanf(in,"%f",(data+k*exp[0].npoints+j))!=1){
	fprintf(stderr,"sh_read_spatial_data: error: scalar format: pixel %i: read error\n",
		(int)j);
	exit(-1);
      }
    }
    /* 
       adjust longitude range 
    */
    if(lon < 0)
      lon += 360.0;
    /* 
       check if location is OK (we don't know about z defaults) 
    */
    if(((fabs(PHI2LON(xp[HC_PHI])-lon) > 1e-3)&&
	(fabs(fabs(PHI2LON(xp[HC_PHI])-lon)-360) > 1e-3))||
       (fabs(THETA2LAT(xp[HC_THETA])-lat) > 1e-3)){
      fprintf(stderr,"sh_read_model_spatial_data: error: pixel %i coordinate mismatch:\n",
	      (int)j);
      fprintf(stderr,"sh_read_model_spatial_data: orig: %g, %g file: %g, %g\n",
	      PHI2LON(xp[HC_PHI]),THETA2LAT(xp[HC_THETA]),lon,lat);
      exit(-1);
    }
  }	/* end points in layer loop */
}

/* 
   
   print the spatial basis coordinates of a single spherical
   harmonics expansion 

   for show_z_label is FALSE, the format is

   lon lat 

   for all the npoints of an expansion

   for show_z_label is TRUE, the format is

   lon lat z

   as passed 

   if out_mode == 0, will write to file *out, 
   
   else will use x[] and store the values

*/
void sh_compute_spatial_basis(struct sh_lms *exp, FILE *out, 
			      hc_boolean use_3d,
			      float z, float **x,
			      int out_mode, /* 0: file 1: store */
			      hc_boolean verbose)
{
  int j,os,inc;
  double xp[3];
  if(out_mode)			/* make room for storing x,y,z */
    hc_svecrealloc(x,exp->npoints*(2+((use_3d)?(1):(0))),"sh_compute_spatial_basis");
  inc = (use_3d)?(3):(2);
  for(j=os=0;j < exp->npoints;j++,os+=inc){
    /* 
       get coordinates 
    */
    switch(exp->type){
    case SH_HEALPIX:
      switch(exp->heal.ordering){
      case SH_HEALPIX_RING:  
	pix2ang_ring((long)exp->heal.nside,(long)j,
		     (xp+HC_THETA),(xp+HC_PHI));
	break;
      case SH_HEALPIX_NEST:  
	pix2ang_nest((long)exp->heal.nside,(long)j,
		     (xp+HC_THETA),(xp+HC_PHI));
	break;
      default:

	fprintf(stderr,"sh_compute_spatial_basis: error: ordering %i undefined\n",
		exp->heal.ordering);
	exit(-1);
	break;
      }
      break;			/* end Healpix part */
    case SH_RICK:
      /* compute the coordinates for Rick's type of expansion */
#ifdef NO_RICK_FORTRAN
      rick_pix2ang(j,exp->lmax,(xp+HC_THETA),(xp+HC_PHI),
		   &exp->rick);
#else
      rick_f90_pix2ang(&j,&exp->lmax,(xp+HC_THETA),(xp+HC_PHI));
#endif
      break;
    default:
      sh_exp_type_error("sh_compute_spatial_basis",exp);
      break;
    }	/* end type of expansion branch */
    if(out_mode){		/* save */
     if(!use_3d){
       /* save in lon lat format */
       *(*x+os)   = (float) PHI2LON(xp[HC_PHI]);
       *(*x+os+1) = (float) THETA2LAT(xp[HC_THETA]);
     }else{
       /* save in lon lat z format */
       *(*x+os)   = (float) PHI2LON(xp[HC_PHI]);
       *(*x+os+1) = (float) THETA2LAT(xp[HC_THETA]);
       *(*x+os+2) = (float) z;
     }
    }else{			/* write to file */
      if(!use_3d){
	/* write in lon lat format */
	fprintf(out,"%g %g\n",PHI2LON(xp[HC_PHI]),
		THETA2LAT(xp[HC_THETA]));
      }else{
	/* write in lon lat z format */
	fprintf(out,"%g %g %g\n",PHI2LON(xp[HC_PHI]),
		THETA2LAT(xp[HC_THETA]),z);
      }
    }
  }
}
/* 


compute the coefficients of a spherical harmonic expansion 

depending on the implementation, this will save the Plm Legendre
factors

input:  data[exp->npoints * (1 + ivec)]
        if ivec == 0, will expand a scalar
	if ivec == 1, will expand the theta, phi part of a vector

	ivec: switch for scalar/vector expansion

	IF IVEC IS EVER TO BE SET TO UNITY AND THE PLM FUNCTIONS
	ARE SAVED, CALL WITH IVEC == 1 THE FIRST TIME TO INITIALIZE 
	VECTOR PLM FACTORS

	save_plm: if TRUE, will save the Legendre factors

input/output:

        plm: Legendre factors, has to be a pointer that is 
	     initialized, e.g. as NULL

	exp: spherical harmonics expansion(s), 
	     has parameters like
             lmax, and will hold the ALM arrays


	     THIS IS ONE EXPANSION FOR IVEC == 0 AND TWO FOR
	     IVEC = 1

*/
void sh_compute_spectral(float *data, int ivec,
			 hc_boolean save_plm,double **plm,
			 struct sh_lms *exp, hc_boolean verbose)
{
  if(save_plm){
    /* 
       this routine will only compute the plm once and performs 
       some sanity checks
    */
    sh_compute_plm((exp+0),ivec,plm,verbose); 
  }
  switch(exp[0].type){
  case SH_HEALPIX:
    HC_ERROR("sh_compute_spectral","healpix: not properly implemented yet");
    if(ivec){
      /* vector part */
      HC_ERROR("sh_compute_spectral","healpix: ivec==1 not implemented yet");
    }else{
      /* 
	 scalar part 
      */
      if(save_plm){
	/* using precomputed Plm */
	heal_map2alm_sc_pre(&exp[0].heal.nside,&exp[0].lmax,
			    &exp[0].lmax,data,exp[0].alm_c, 
			    &exp[0].heal.cos_theta_cut,
			    exp[0].heal.weights,*plm);
      }else{
	/* compute Plm now */
	heal_map2alm_sc(&exp[0].heal.nside,&exp[0].lmax,
			&exp[0].lmax,data,exp[0].alm_c,
			&exp[0].heal.cos_theta_cut,
			exp[0].heal.weights);
      }
    }
    break;
  case SH_RICK:
    /* 
       compute either scalar expansion of data[n] array
       poloidal and toroidal fields of data[2*n].

       if ivec == 0, exp[1].alm will not be referenced
    */
#ifdef NO_RICK_FORTRAN
    if(save_plm)
      rick_shd2c_pre(data,(data+exp[0].npoints),exp[0].lmax,
		     *plm,(*plm+exp->n_plm),
		     ivec,exp[0].alm,exp[1].alm,&exp->rick);
    
    else
      rick_shd2c(data,(data+exp[0].npoints),exp[0].lmax,ivec,
		 exp[0].alm,exp[1].alm,&exp->rick);
#else
    if(save_plm)
      rick_f90_shd2c_pre(data,(data+exp[0].npoints),&exp[0].lmax,
		     *plm,(*plm+exp->n_plm),
		     &ivec,exp[0].alm,exp[1].alm);
    
    else
      rick_f90_shd2c(data,(data+exp[0].npoints),&exp[0].lmax,&ivec,
		 exp[0].alm,exp[1].alm);
#endif
    break;
  default:
    sh_exp_type_error("sh_compute_spectral",exp);
    break;
  }
  exp[0].spectral_init = TRUE;
  if(ivec)
    exp[1].spectral_init = TRUE;
}
/* 


compute the spatial correspondence of a spherical harmonic expansion
depending on the implementation, this will save the Plm Legendre
factors

spatial output will be in data in the ordering required by the spherical
haronics method

input: exp (with parameters and alm) [1+ivec]

ivec: use vectors or not 

input/output: data
 
the DATA array has to be exp->npoints * (1 + ivec) = exp->tnpoints

*/
void sh_compute_spatial(struct sh_lms *exp, int ivec,
			hc_boolean save_plm,double **plm,
			float *data, hc_boolean verbose)
{
  if((!exp[0].spectral_init)||(ivec && !exp[1].spectral_init)){
    fprintf(stderr,"sh_compute_spatial: coefficients set not initialized, ivec: %i\n",
	    ivec);
    exit(-1);
  }
  /* 
     make sure that the Legendre factors are computed 
  */
  if(save_plm){
    /* 
       this routine will only compute the plm once and performs 
       some sanity checks
    */
    sh_compute_plm(exp,ivec,plm,verbose); 
  }
  switch(exp->type){
  case SH_HEALPIX:
    if(ivec){
      HC_ERROR("sh_compute_spectral","healpix: ivec==1 not implemented yet");
    }else{
      /* 
	 scalar
      */
      if(save_plm){/* using precomputed Plm */
	heal_alm2map_sc_pre(&exp[0].heal.nside,&exp[0].lmax,
			    &exp[0].lmax,exp[0].alm_c,data,
			    *plm);
      }else{/* compute Plm now */
	heal_alm2map_sc(&exp[0].heal.nside,&exp[0].lmax,
			&exp[0].lmax,exp[0].alm_c,data);
      }
    }
    break;			/* end Healpix */
  case SH_RICK:
#ifdef NO_RICK_FORTRAN
    if(save_plm)
      rick_shc2d_pre(exp[0].alm,exp[1].alm,exp[0].lmax,
		     *plm,(*plm+exp->n_plm),
		     ivec,data,(data+exp[0].npoints),
		     &exp->rick);
    else
      rick_shc2d(exp[0].alm,exp[1].alm,exp[0].lmax,ivec,
		 data,(data+exp[0].npoints),&exp->rick);
#else
    if(save_plm)
      rick_f90_shc2d_pre(exp[0].alm,exp[1].alm,&exp[0].lmax,
		     *plm,(*plm+exp->n_plm),
		     &ivec,data,(data+exp[0].npoints));
    else
      rick_f90_shc2d(exp[0].alm,exp[1].alm,&exp[0].lmax,&ivec,
		 data,(data+exp[0].npoints));
#endif
    break;
  default:
    sh_exp_type_error("sh_compute_spatial",exp);
    break;
  }


  
}
/* 
   
print an error message and exit if a spherical harmonics type is not
defined

*/
void sh_exp_type_error(char *subroutine,struct sh_lms *exp)
{
  fprintf(stderr,"%s: error: spherical harmonics type %i undefined\n",
	  subroutine,exp->type);
  exit(-1);
}
/* 

print the Plm factors

*/
void sh_print_plm(double *plm, int n_plm, int ivec, int type,
		  FILE *out)
{
  int i,j,jlim;
  switch(type){
  case SH_HEALPIX:
    jlim=(ivec)?(3):(1);
    for(i=0;i < n_plm;i++){	/* number of points loop */
      for(j=0;j < jlim;j++)	/* scalar or scalar + pol? */
	fprintf(out,"%12.5e ",plm[j*n_plm+i]);
      fprintf(out,"\n");
    }
    break;
  case SH_RICK:
    jlim=(ivec)?(2):(1);
    for(i=0;i < n_plm;i++){	/* number of points loop */
      for(j=0;j < jlim;j++)	/* scalar or scalar + pol? */
	fprintf(out,"%12.5e ",plm[j*n_plm+i]);
      fprintf(out,"\n");
    }
    break;
  default:
    fprintf(stderr,"sh_print_plm: expansion type %i undefined\n",
	    type);
    exit(-1);
  }
}
/* 

print the spatial equivalent of a spherical harmonic expansion with
npoints spatial points in the format

coordinates data

for 
use_3d: coordinates = lon lat z
else  : coordinates = lon lat

shps is the number of scalars that are passed in the data[shps * npoints] array

*/
void sh_print_spatial_data(struct sh_lms *exp, int shps, 
			   float *data, hc_boolean use_3d,
			   float z, FILE *out)
{
  int j,k;
  double xp[3],lon,lat;
  for(j=0;j < exp[0].npoints;j++){
    /* 
       get coordinates
    */
    switch(exp->type){
    case SH_HEALPIX:
      switch(exp[0].heal.ordering){
      case SH_HEALPIX_RING:  
	pix2ang_ring((long)exp[0].heal.nside,(long)j,(xp+HC_THETA),(xp+HC_PHI));
	break;
      case SH_HEALPIX_NEST:  
	pix2ang_nest((long)exp[0].heal.nside,(long)j,(xp+HC_THETA),(xp+HC_PHI));
	break;
      default:
	fprintf(stderr,"print_sh_spatial_data: error: ordering %i undefined\n",
		exp[0].heal.ordering);
	exit(-1);
	break;
      }
      break;			/* end Healpix branch */
    case SH_RICK:
      /* compute location */
#ifdef NO_RICK_FORTRAN
      rick_pix2ang(j,exp[0].lmax,(xp+HC_THETA),(xp+HC_PHI),
		   &exp->rick);
#else
      rick_f90_pix2ang(&j,&exp[0].lmax,(xp+HC_THETA),(xp+HC_PHI));
#endif
      break;
    default:
      sh_exp_type_error("sh_print_spatial_data",exp);
      break;
    }	/* end type branch */
    lon = PHI2LON(xp[HC_PHI]);
    lat = THETA2LAT(xp[HC_THETA]);
    /* print coordinates */
    if(!use_3d){
      /* print lon lat  */
      fprintf(out,"%11g %11g\t",lon,lat);
    }else{
      /* print lon lat z[i] */
      fprintf(out,"%11g %11g %11g\t",lon,lat,z);
    }
    for(k=0;k<shps;k++)		/* loop through all scalars */
      fprintf(out,"%11g ",data[j+exp[0].npoints*k]);
    fprintf(out,"\n");
  }	/* end points in lateral space loop */
}
/* 

compute the associated Legendre functions for all (l,m) at 
all latidutinal lcoations once and only once

input:
exp: holds the expansion parameters
ivec_global: if 1, will construct vector arrays, else only for scalar

output:

plm: will be re-allocated, has to be passed at least as NULL

*/
void sh_compute_plm(struct sh_lms *exp,int ivec,double **plm,
		    hc_boolean verbose)
{
  static hc_boolean plm_computed = FALSE;
  static int old_lmax,old_ivec,old_tnplm;
  if(!plm_computed){
    if((!exp->lmax)||(!exp->n_plm)||(!exp->tn_plm)){
      fprintf(stderr,"sh_compute_plm: error, expansion not initialized?\n");
      fprintf(stderr,"sh_compute_plm: lmax: %i n_plm: %i tn_plm: %i\n",
	      exp->lmax,exp->n_plm,exp->tn_plm);
      exit(-1);
    }
    /* 
       allocate 
    */
    hc_dvecrealloc(plm,exp->tn_plm,"sh_compute_plm");
    /* 
       compute the Legendre polynomials 
    */
    switch(exp->type){
    case SH_HEALPIX:
      if(verbose)
	fprintf(stderr,"sh_compute_plm: healpix: computing Plm for lmax %i\n",
		exp->lmax);
      heal_plmgen(*plm,&exp->heal.nside,&exp->lmax,&ivec);
      break;
    case SH_RICK:
      if(verbose)
	fprintf(stderr,"sh_compute_plm: Rick: computing all Plm for lmax %i\n",
		exp->lmax);
#ifdef NO_RICK_FORTRAN
      rick_compute_allplm(exp->lmax,ivec,*plm,
			  (*plm+exp->n_plm),&exp->rick);
#else
      rick_f90_compute_allplm(&exp->lmax,&ivec,*plm,
			      (*plm+exp->n_plm));
#endif
      break;
    default:
      sh_exp_type_error("compute_plm",exp);
      break;
    }
    plm_computed = TRUE;
    old_lmax = exp->lmax;
    old_ivec = ivec;
    old_tnplm = exp->tn_plm;
  }else{
    /* 
       simple checks
       
       first lmax
    */
    if(old_lmax != exp->lmax){
      fprintf(stderr,"sh_compute_plm: error: lmax initially %i, now %i\n",
	      old_lmax,exp->lmax);
      exit(-1);
    }
    /* check if ivec was initialized if ever used  */
    if(ivec > old_ivec){
      fprintf(stderr,"sh_compute_plm: error: plm are to be saved but routine was initialized\n");
      fprintf(stderr,"sh_compute_plm: error: with ivec: %i and now we want vectors, ivec: %i\n",
	      old_ivec,ivec);
      exit(-1);
    }
    if(exp->tn_plm != old_tnplm){
      fprintf(stderr,"sh_compute_plm: error: tn_plm initially %i, now %i\n",
	      old_tnplm,exp->tn_plm);
      exit(-1);
    }
  }
}
/* 
   
returns the l,m A (use_b=0) or B (use_b=1) or A and B (use_b=2)
coefficient(s) of an expansion. if phys_normalization is set, 
will change the normalization so that the output is in the 
real spherical harmonics as in Dahlen and Tromp. 

else, will leave in the original convention, what ever it is 
stored in

for m==0, B will be returned as zero

*/
void sh_get_coeff(struct sh_lms *exp,int l, int m, int use_b, 
		  hc_boolean phys_norm, HC_CPREC *value)
{
  static HC_CPREC sqrt2 = SQRT_TWO;
  HC_CPREC s1;
  int index;
#ifdef DEBUG
  /* do some checks */
  if((m > l)||(l<0)||(m<0)){
    fprintf(stderr,"sh_get_coeff: error: attempting to read l=%i and m=%i\n",
	    l,m);
    exit(-1);
  }
  if(l > exp->lmax){
    fprintf(stderr,"sh_get_coeff: error: attempting to read l=%i to lmax=%i expansion\n",
	    l,exp->lmax);
    exit(-1);
  }
  if((use_b < 0)||(use_b>2)){
    fprintf(stderr,"sh_get_coeff: error: attempting to read use_b=%i expansion (should be 0,1, or 2)\n",
	    use_b);
    exit(-1);
  }
#endif
  switch(exp->type){
  case SH_HEALPIX:
    /* 
       healpix is stored in complex number format, convert to real
       expansion coefficients
    */
    if(phys_norm){		/* convert */
      s1=(m==0)?(1.0):(sqrt2);
      if(use_b == 0)
	*value = (HC_CPREC) s1 * exp->alm_c[heal_index(&exp->heal,l,m)].dr;
      else if(use_b == 1)
	*value =   (m != 0)?((HC_CPREC)-s1 * exp->alm_c[heal_index(&exp->heal,l,m)].di):(0.0);
      else{			/* a and b needed */
	value[0] = (HC_CPREC) s1 * 
	  exp->alm_c[(index=heal_index(&exp->heal,l,m))].dr;
	value[1] = (m != 0)?((HC_CPREC)-s1 * exp->alm_c[index].di):(0.0);
      }
    }else{			/* leave as is  */
      if(use_b == 0)
	*value = (HC_CPREC)exp->alm_c[heal_index(&exp->heal,l,m)].dr;
      else if(use_b == 1){
	*value = (m != 0)?((HC_CPREC)exp->alm_c[heal_index(&exp->heal,l,m)].di):(0.0);
      }else{
	value[0] =  (HC_CPREC)exp->alm_c[(index=heal_index(&exp->heal,l,m))].dr;
	value[1] =  (m != 0)?((HC_CPREC)exp->alm_c[index].di):(0.0);
      }
    }
    break;
  case SH_RICK:
    if(use_b < 2){		/* A or B */
      if(use_b && (m==0)){
	*value = 0.0;
      }else{
	if(phys_norm){
	  *value = (HC_CPREC)exp->alm[LM_INDEX(l,m,use_b)] * 
	    SH_RICK_FACTOR(l,m);
	}else{
	  *value = (HC_CPREC)exp->alm[LM_INDEX(l,m,use_b)];
	}
      }
    }else{ 			/* both  */
      index = LM_INDEX(l,m,0);
      if(phys_norm){
	s1 = SH_RICK_FACTOR(l,m);
	value[0] = (HC_CPREC)exp->alm[index  ]* s1;
	value[1] = (m != 0)?((HC_CPREC)exp->alm[index+1]* s1):(0.0);
      }else{
	value[0] = (HC_CPREC)exp->alm[index];
	value[1] = (m != 0)?((HC_CPREC)exp->alm[index+1]):(0.0);
      }
    }
    break;
  default:
    sh_exp_type_error("sh_read_coefficients",exp);
    break;
  }
}
/*  
    
write value "value" to the expansion,. if phys_norm is set, will
convert from real spherical harmonics as in Dahlen and Tromp to
different internal convention

if use_b = 0: write A coefficient from value[0]
if use_b = 1: write B coefficient from value[0]
if use_b = 2: write A and B coefficient from value[0] and value[1]


*/
void sh_write_coeff(struct sh_lms *exp,int l, int m, 
		    int use_b,hc_boolean phys_norm, 
		    HC_CPREC *value)
{
  static HC_CPREC sqrt2 = SQRT_TWO;
  HC_CPREC s1;
  int index;
#ifdef DEBUG
  /* do some checks */
  if((m > l)||(l<0)||(m<0)){
    fprintf(stderr,"sh_write_coeff: error: attempting to write l=%i and m=%i\n",
	    l,m);
    exit(-1);
  }
  if(l > exp->lmax){
    fprintf(stderr,"sh_write_coeff: error: attempting to write l=%i to lmax=%i expansion\n",
	    l,exp->lmax);
    exit(-1);
  }
  if((use_b < 0)||(use_b>2)){
    fprintf(stderr,"sh_write_coeff: error: attempting to write use_b=%i expansion (should be 0,1, or 2)\n",
	    use_b);
    exit(-1);
  }
#endif
  if((m==0) && (use_b > 0)){
    fprintf(stderr,"sh_write_coeff: error: can't assign B coefficient for m == 0 (l: %i)\n",
	    l);
    exit(-1);
  }
  switch(exp->type){
  case SH_HEALPIX:
    /* 
       healpix is stored in complex number format, convert to real
       expansion coefficients
    */
    index = heal_index(&exp->heal,l,m);
    if(phys_norm){		/* convert */
      s1=(m==0)?(1.0):(sqrt2);
      if(use_b == 0)
	exp->alm_c[index].dr =   *value/s1;
      else if(use_b == 1)
	exp->alm_c[index].di = -(*value)/s1;
      else{
	exp->alm_c[index].dr =   value[0]/s1;
	exp->alm_c[index].di = - value[1]/s1;
      }
    }else{			/* use as is */
       if(use_b == 0)
	 exp->alm_c[index].dr = *value;
       else if(use_b == 1)
	 exp->alm_c[index].di = *value;
      else{
	exp->alm_c[index].dr = value[0];
	exp->alm_c[index].di = value[1];
      }
    }
    break;
  case SH_RICK:
    if(phys_norm){		/* convert */
      if(use_b < 2){		/* A or B */
	exp->alm[LM_INDEX(l,m,use_b)] = 
	  *value / SH_RICK_FACTOR(l,m);
      }else{			/* both */
	exp->alm[(index=LM_INDEX(l,m,0))] = 
	  value[0] / (s1=SH_RICK_FACTOR(l,m));
	exp->alm[index+1] = value[1] / s1;
      }
    }else{			/* as is */
      if(use_b < 2){		/* A or B */
	exp->alm[LM_INDEX(l,m,use_b)] = *value;
      }else{			/* both */
	exp->alm[(index = LM_INDEX(l,m,0))]   = value[0];
	exp->alm[index+1] = value[1];
      }
    } 
    break;
  default:
    sh_exp_type_error("sh_write_coefficients",exp);
    break;
  }
}
/* 
   copy the coefficients of one expansion to another 

   a = b

*/
void sh_aexp_equals_bexp_coeff(struct sh_lms *a, struct sh_lms *b)
{
  int i;
  if(a->type != b->type){
    fprintf(stderr,"sh_aexp_equals_bexp_coeff: error: type mix (%i vs. %i) not implemented yet\n",
	    a->type,b->type);
    exit(-1);
  }
  /* 
     make sure lmax(b) <= lmax(a). if lmax(b) < lmax(a), the rest 
     of the coefficients in a will be set to zero

  */
  if(a->lmax < b->lmax){
    fprintf(stderr,"sh_aexp_equals_bexp_coeff: error: lmax(a): %i < lmax(b): %i\n",
	    a->lmax,b->lmax);
    exit(-1);
  }
  switch(a->type){
  case SH_HEALPIX:			/* nplm should reflect the lmax */
    for(i=0;i < b->n_lm;i++){
      a->alm_c[i].dr = b->alm_c[i].dr;
      a->alm_c[i].di = b->alm_c[i].di;
    }
    for(i=b->n_lm;i < a->n_lm;i++)
      a->alm_c[i].dr = a->alm_c[i].di = 0.0;
    break;
  case SH_RICK:
    for(i=0;i < b->n_lm;i++)
      a->alm[i] = b->alm[i];
    for(i=b->n_lm;i < a->n_lm;i++)
      a->alm[i] = 0.0;
    break;
  default:
    sh_exp_type_error("sh_aexp_equals_bexp_coeff",a);
    break;
  }
}
/* 

given a spherical harmonic expansion, scale it with factor fac[0...lmax] 
which only depends on l


*/
void sh_scale_expansion_l_factor(struct sh_lms *exp, HC_CPREC *lfac)
{
  int l,m,index;
  HC_CPREC fac;
  switch(exp->type){
  case SH_HEALPIX:
    for(l=0;l <= exp->lmax;l++){
      fac = lfac[l];
      for(m=0;m <= l;m++){
	exp->alm_c[(index = heal_index(&exp->heal,l,m))].dr * fac;
	exp->alm_c[index].di *= fac;
      }
    }
    break;
  case SH_RICK:
    for(l=0;l <= exp->lmax;l++){
      fac = lfac[l];
      for(m=0;m <= l;m++){
	exp->alm[(index = LM_INDEX(l,m,0))] *= fac;
	exp->alm[index+1] *= fac;
      }
    }
    break;
  default:
    sh_exp_type_error("sh_scale_expansion_l_factor",exp);
    break;
 }
}
/* scale all coefficients */
void sh_scale_expansion(struct sh_lms *exp, HC_CPREC fac)
{
  int l,m,index;
  switch(exp->type){
  case SH_HEALPIX:
    for(l=0;l <= exp->lmax;l++)
      for(m=0;m <= l;m++){
	exp->alm_c[(index = heal_index(&exp->heal,l,m))].dr * fac;
	exp->alm_c[index].di *= fac;
      }
    break;
  case SH_RICK:
    for(l=0;l <= exp->lmax;l++)
      for(m=0;m <= l;m++){
	exp->alm[(index = LM_INDEX(l,m,0))] *= fac;
	exp->alm[index+1] *= fac;
      }
    break;
  default:
    sh_exp_type_error("sh_scale_expansion",exp);
    break;
 }
}
@


1.14
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.13 2004/12/20 05:18:12 becker Exp becker $
d22 1
d202 2
a203 1
void sh_compute_power_per_degree(struct sh_lms *exp, float *power)
d1216 1
a1216 1
	  *value = (HC_CPREC)exp->alm[LM_INDEX(l,m,use_b)] * \
@


1.13
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.12 2004/12/20 05:09:42 becker Exp becker $
d120 5
d127 1
d183 1
a183 1
CPREC sh_total_power(struct sh_lms *exp)
d190 1
a190 1
    sum += (2.0*(CPREC)l+1.0) * power[l];
d192 1
a192 1
  return (CPREC)sum;
d204 1
a204 1
  CPREC value[2];
d215 1
a215 1
    power[l] /= 2.0*((CPREC)l)+1.0;
d238 1
a238 1
			 int ilayer, int nset,CPREC zlabel,
d312 1
a312 1
			      CPREC *zlabel,int *ivec,
d337 1
a337 1
      *zlabel = (CPREC) fz; 
d352 1
a352 1
      *zlabel = (CPREC)dtmp;
d420 1
a420 1
			   CPREC *fac,hc_boolean binary, 
d424 1
a424 1
  CPREC value[2];
d481 1
a481 1
			  FILE *in, hc_boolean binary, CPREC *fac,
d485 1
a485 1
  CPREC value[2]={0,0};
d516 1
a516 1
	    value[k] = (CPREC)fvalue[k];
d568 2
a569 1
void sh_read_spatial_data(struct sh_lms *exp, FILE *in, my_boolean use_3d, 
d601 4
d606 1
d722 4
d727 1
d834 10
d852 1
d919 10
d936 1
a936 1

d1032 4
d1037 1
d1102 4
d1108 1
d1157 1
a1157 1
		  hc_boolean phys_norm, CPREC *value)
d1159 2
a1160 2
  static CPREC sqrt2 = SQRT_TWO;
  CPREC s1;
d1189 1
a1189 1
	*value = (CPREC) s1 * exp->alm_c[heal_index(&exp->heal,l,m)].dr;
d1191 1
a1191 1
	*value =   (m != 0)?((CPREC)-s1 * exp->alm_c[heal_index(&exp->heal,l,m)].di):(0.0);
d1193 1
a1193 1
	value[0] = (CPREC) s1 * 
d1195 1
a1195 1
	value[1] = (m != 0)?((CPREC)-s1 * exp->alm_c[index].di):(0.0);
d1199 1
a1199 1
	*value = (CPREC)exp->alm_c[heal_index(&exp->heal,l,m)].dr;
d1201 1
a1201 1
	*value = (m != 0)?((CPREC)exp->alm_c[heal_index(&exp->heal,l,m)].di):(0.0);
d1203 2
a1204 2
	value[0] =  (CPREC)exp->alm_c[(index=heal_index(&exp->heal,l,m))].dr;
	value[1] =  (m != 0)?((CPREC)exp->alm_c[index].di):(0.0);
d1214 1
a1214 1
	  *value = (CPREC)exp->alm[LM_INDEX(l,m,use_b)] * \
d1217 1
a1217 1
	  *value = (CPREC)exp->alm[LM_INDEX(l,m,use_b)];
d1224 2
a1225 2
	value[0] = (CPREC)exp->alm[index  ]* s1;
	value[1] = (m != 0)?((CPREC)exp->alm[index+1]* s1):(0.0);
d1227 2
a1228 2
	value[0] = (CPREC)exp->alm[index];
	value[1] = (m != 0)?((CPREC)exp->alm[index+1]):(0.0);
d1251 1
a1251 1
		    CPREC *value)
d1253 2
a1254 2
  static CPREC sqrt2 = SQRT_TWO;
  CPREC s1;
d1382 1
a1382 1
void sh_scale_expansion_l_factor(struct sh_lms *exp, CPREC *lfac)
d1385 1
a1385 1
  CPREC fac;
d1411 1
a1411 1
void sh_scale_expansion(struct sh_lms *exp, CPREC fac)
@


1.12
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.11 2004/12/01 01:25:35 becker Exp becker $
a21 2

  float x;
a236 1
  int i;
d367 1
a367 1
	    type);
a777 1
  SH_RICK_PREC *dummy;
@


1.11
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.10 2004/11/24 02:09:00 becker Exp becker $
d18 1
a18 1
void sh_allocate_and_init(struct lms **exp, int n,int lmax, 
d24 1
a24 1
  *exp = (struct lms *)calloc(n,sizeof(struct lms));
d45 1
a45 1
void sh_init_expansion(struct lms *exp, int lmax, int type, 
d133 1
a133 1
void sh_free_expansion(struct lms *exp, int n)
d154 1
a154 1
void sh_clear_alm(struct lms *exp)
d179 1
a179 1
CPREC sh_total_power(struct lms *exp)
d197 1
a197 1
void sh_compute_power_per_degree(struct lms *exp, float *power)
d233 1
a233 1
void sh_print_parameters(struct lms *exp, int shps,
d416 1
a416 1
void sh_print_coefficients(struct lms *exp, int shps, FILE *out, 
d477 1
a477 1
void sh_read_coefficients(struct lms *exp, int shps, int lmax,
d565 1
a565 1
void sh_read_spatial_data(struct lms *exp, FILE *in, my_boolean use_3d, 
d677 1
a677 1
void sh_compute_spatial_basis(struct lms *exp, FILE *out, 
d779 1
a779 1
			 struct lms *exp, hc_boolean verbose)
d857 1
a857 1
void sh_compute_spatial(struct lms *exp, int ivec,
d918 1
a918 1
void sh_exp_type_error(char *subroutine,struct lms *exp)
d970 1
a970 1
void sh_print_spatial_data(struct lms *exp, int shps, 
d1033 1
a1033 1
void sh_compute_plm(struct lms *exp,int ivec,double **plm,
d1112 1
a1112 1
void sh_get_coeff(struct lms *exp,int l, int m, int use_b, 
d1205 1
a1205 1
void sh_write_coeff(struct lms *exp,int l, int m, 
d1293 1
a1293 1
void sh_aexp_equals_bexp_coeff(struct lms *a, struct lms *b)
d1338 1
a1338 1
void sh_scale_expansion_l_factor(struct lms *exp, CPREC *lfac)
d1367 1
a1367 1
void sh_scale_expansion(struct lms *exp, CPREC fac)
@


1.10
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.9 2004/08/09 23:19:24 becker Exp becker $
d26 1
a26 1
    MEMERROR("sh_allocate_and_init");
d131 1
a131 1
   free an expansion structure 
d133 1
a133 1
void sh_free_expansion(struct lms *exp)
d135 14
a148 11
  switch(exp->type){
  case SH_HEALPIX:			/* SH_HEALPIX part */
    heal_free_structure(&exp->heal);
    free(exp->alm_c);
    break;
  case SH_RICK:
    free(exp->alm);
    break;
  default:
    sh_exp_type_error("sh_free_expansion",exp);
    break;
d442 1
d452 1
d472 3
d477 2
a478 2
void sh_read_coefficients(struct lms *exp, int shps, FILE *in, 
			  hc_boolean binary, CPREC *fac,
d481 7
a487 3
  int j,k,l,m;
  CPREC value[2];
  HC_BIN_PREC fvalue[2];
d504 1
a504 1
    for(l=0;l <= exp[0].lmax;l++)
d519 1
a519 1
    for(l=0;l <= exp[0].lmax;l++)
d523 2
a524 2
	    fprintf(stderr,"sh_read_coefficients: read error: set %i l %i m %i\n",
		    j+1,l,m);
d532 9
a540 1
  for(j=0;j<shps;j++){
d582 1
a582 1
		     (xp+THETA),(xp+PHI));
d586 1
a586 1
		     (xp+THETA),(xp+PHI));
d597 1
a597 1
      rick_f90_pix2ang(&j,&exp->lmax,(xp+THETA),(xp+PHI));
d643 3
a645 3
    if(((fabs(PHI2LON(xp[PHI])-lon) > 1e-3)&&
	(fabs(fabs(PHI2LON(xp[PHI])-lon)-360) > 1e-3))||
       (fabs(THETA2LAT(xp[THETA])-lat) > 1e-3)){
d649 1
a649 1
	      PHI2LON(xp[PHI]),THETA2LAT(xp[THETA]),lon,lat);
d697 1
a697 1
		     (xp+THETA),(xp+PHI));
d701 1
a701 1
		     (xp+THETA),(xp+PHI));
d713 1
a713 1
      rick_f90_pix2ang(&j,&exp->lmax,(xp+THETA),(xp+PHI));
d722 2
a723 2
       *(*x+os)   = (float) PHI2LON(xp[PHI]);
       *(*x+os+1) = (float) THETA2LAT(xp[THETA]);
d726 2
a727 2
       *(*x+os)   = (float) PHI2LON(xp[PHI]);
       *(*x+os+1) = (float) THETA2LAT(xp[THETA]);
d733 2
a734 2
	fprintf(out,"%g %g\n",PHI2LON(xp[PHI]),
		THETA2LAT(xp[THETA]));
d737 2
a738 2
	fprintf(out,"%g %g %g\n",PHI2LON(xp[PHI]),
		THETA2LAT(xp[THETA]),z);
d984 1
a984 1
	pix2ang_ring((long)exp[0].heal.nside,(long)j,(xp+THETA),(xp+PHI));
d987 1
a987 1
	pix2ang_nest((long)exp[0].heal.nside,(long)j,(xp+THETA),(xp+PHI));
d998 1
a998 1
      rick_f90_pix2ang(&j,&exp[0].lmax,(xp+THETA),(xp+PHI));
d1004 2
a1005 2
    lon = PHI2LON(xp[PHI]);
    lat = THETA2LAT(xp[THETA]);
d1102 6
a1107 3
coefficient(s) of an expansion. if phys_normalization is set, will
change the normalization to real spherical harmonics as in Dahlen and
Tromp. else, will leave in the original convention
d1170 2
a1171 1
	  *value = (CPREC)exp->alm[LM_INDEX(l,m,use_b)] * SH_RICK_FACTOR(l,m);
@


1.9
log
@changed bla balc
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.8 2004/08/06 00:38:36 becker Exp becker $
d22 2
d176 1
a176 1
CPREC sh_power(struct lms *exp)
d180 1
a180 1
  hc_svecalloc(&power,exp->lmaxp1,"sh_power");
d196 14
a209 12
  switch(exp->type){
  case SH_HEALPIX:
    /* init with zeroes */
    heal_compute_power(exp->alm_c,&exp->lmax,power);
    break;
  case SH_RICK:
    rick_f90_compute_power(exp->alm,&exp->lmax,power);
    break;
  default:
    sh_exp_type_error("sh_compute_power_per_degree",exp);
    break;
  }
d282 11
d296 1
a296 1
   il;ayer: 0..nset
d350 1
d771 1
@


1.8
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.7 2004/07/30 23:52:04 becker Exp becker $
d443 3
a445 2
read in spherical harmonic coefficients in real, phsyics convention
of Dahlen and Tromp p. 859
d509 110
@


1.7
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.6 2004/07/02 00:14:44 becker Exp becker $
d25 1
a25 1
  for(i=0;i<n;i++)
d27 1
d50 1
a50 1
  /* type of expansion, e.g. HEALPIX or RICK, this will be checked later */
d83 1
a83 1
  case HEALPIX:			/* HEALPIX part */
d89 2
a90 2
    exp->nplm = exp->lmbig;
    hc_scmplx_vecalloc(&exp->alm_c,exp->nplm,"init_expansion");
d92 1
a92 1
     /* 
d96 1
a96 1
    heal_init_parameters(&exp->heal,(lmax/2)+2,HEALPIX_RING,
d98 1
a98 1
			 &exp->nplm,&exp->tnplm);
d101 1
a101 1
  case RICK:			/* RICK PART */
d105 1
a105 1
    exp->nplm = exp->lmsmall2;
d109 2
a110 2
#ifdef RICK_DOUBLE_PRECISION
    hc_dvecalloc(&exp->alm,exp->nplm,"sh_init_expansion");
d112 1
a112 1
    hc_svecalloc(&exp->alm,exp->nplm,"sh_init_expansion");
a114 1
   
d121 1
a121 1
		  &exp->nplm,&exp->tnplm);
d134 1
a134 1
  case HEALPIX:			/* HEALPIX part */
d138 1
a138 1
  case RICK:
d153 1
a153 1
  case HEALPIX:
d155 1
a155 1
    for(i=0;i<exp->nplm;i++)
d158 2
a159 2
  case RICK:
    for(i=0;i<exp->nplm;i++)
d195 1
a195 1
  case HEALPIX:
d199 1
a199 1
  case RICK:
d216 8
a223 1
ilayer is the layer index (0...nset-1) for nset layers
a224 1
zlabel a label for layer ilayer
d236 1
a236 1
     lmax i+1 z[i] nset shps expansion_type
a238 3
  if(short_format && (shps != 2))
    fprintf(stderr,"sh_print_parameters: WARNING: short format but shps: %i\n",
	    shps);
a240 1
    i = ilayer+1;
d243 1
a243 1
      fwrite(&i,sizeof(int),1,out);
d252 1
a252 1
	      exp[0].lmax,ilayer+1,zlabel,nset,
d262 2
a263 3
  case RICK:
    break;
  case HEALPIX:
d277 11
d335 2
a336 2
    *zlabel = 0.0; *ilayer = 1; *nset=1;
    *shps = 1;     *type=RICK;
a337 1
  *ilayer -= 1;
d346 2
a347 3
  case RICK:
    break;
  case HEALPIX:
d456 1
a456 1
  int j,l,m;
d483 2
a484 2
	  value[0] = (CPREC)fvalue[0];
	  value[1] = (CPREC)fvalue[1];
d487 1
a487 1
	  sh_write_coeff((exp+j),l,m,2,TRUE,value);
d500 1
a500 1
	  sh_write_coeff((exp+j),l,m,2,TRUE,value);
d503 1
a503 1
  for(j=0;j<shps;j++)
d505 2
d524 5
d530 5
a534 3
void sh_print_spatial_basis(struct lms *exp, FILE *out, 
			    hc_boolean show_z_label,
			    float z, hc_boolean verbose)
d536 1
a536 1
  int j;
d538 4
a541 1
  for(j=0;j < exp->npoints;j++){
d546 1
a546 1
    case HEALPIX:
d548 1
a548 1
      case HEALPIX_RING:  
d552 1
a552 1
      case HEALPIX_NEST:  
d557 2
a558 1
	fprintf(stderr,"sh_print_spatial_basis: error: ordering %i undefined\n",
d564 1
a564 1
    case RICK:
d569 1
a569 1
      sh_exp_type_error("sh_print_spatial_basis",exp);
d572 21
a592 8
    if(!show_z_label){
      /* write in lon lat format */
      fprintf(out,"%g %g\n",PHI2LON(xp[PHI]),
	      THETA2LAT(xp[THETA]));
    }else{
      /* write in lon lat z format */
      fprintf(out,"%g %g %g\n",PHI2LON(xp[PHI]),
	      THETA2LAT(xp[THETA]),z);
d634 1
a634 1
  RICK_PREC *dummy;
d643 1
a643 1
  case HEALPIX:
d666 1
a666 1
  case RICK:
d675 1
a675 1
		     *plm,(*plm+exp->nplm),
d704 3
a706 4
output: data

DATA HAS TO BE INITIALIZED (e.g. as NULL), will be resized to
exp->npoints * (1 + ivec)
d713 5
a717 2
  if((!exp[0].spectral_init)||(ivec && !exp[1].spectral_init))
    HC_ERROR("sh_compute_spatial","coefficients set not initialized");
d726 1
a726 1
    sh_compute_plm((exp+0),ivec,plm,verbose); 
d729 1
a729 1
  case HEALPIX:
d746 1
a746 1
  case RICK:
d749 1
a749 1
		     *plm,(*plm+exp->nplm),
d760 3
d781 1
a781 1
void sh_print_plm(double *plm, int nplm, int ivec, int type,
d786 1
a786 1
  case HEALPIX:
d788 1
a788 1
    for(i=0;i < nplm;i++){	/* number of points loop */
d790 1
a790 1
	fprintf(out,"%12.5e ",plm[j*nplm+i]);
d794 1
a794 1
  case RICK:
d796 1
a796 1
    for(i=0;i < nplm;i++){	/* number of points loop */
d798 1
a798 1
	fprintf(out,"%12.5e ",plm[j*nplm+i]);
d810 2
a811 2
print the spatial equivalent of a spherical harmonic expansion
in format
d815 3
a817 2
nset = 1: coordinates = lon lat
nset > 1: coordinates = lon lat z
d819 1
a819 2
ivec = 0: data = scalar
ivec = 1: data = u_r u_theta u_phi
d822 2
a823 2
void sh_print_spatial_data(struct lms *exp, int ivec, 
			   float *data, hc_boolean show_z_label,
d826 1
a826 1
  int j;
a827 6
  /* print data for each layer */
  if(ivec == 1){
    if((exp[1].npoints != exp[0].npoints)||
       (exp[2].npoints != exp[0].npoints))
      HC_ERROR("sh_print_spatial_data","mismatch of npoints for exp set");
  }
d829 3
a831 1
    /* get coordinates  */
d833 1
a833 1
    case HEALPIX:
d835 1
a835 1
      case HEALPIX_RING:  
d838 1
a838 1
      case HEALPIX_NEST:  
d848 1
a848 1
    case RICK:
d859 1
a859 1
    if(show_z_label == 1){
d866 4
a869 8
    if(ivec == 0){
      fprintf(out,"%11g\n",data[j]);
    }else{
      fprintf(out,"%11g %11g %11g\n",
	      data[j],data[exp[0].npoints+j],
	      data[exp[1].npoints+j]);
    }
  }	/* end layer loop */
d891 6
d900 1
a900 1
    hc_dvecrealloc(plm,exp->tnplm,"sh_compute_plm");
d905 1
a905 1
    case HEALPIX:
d911 1
a911 1
    case RICK:
d916 1
a916 1
			      (*plm+exp->nplm));
d925 1
a925 1
    old_tnplm = exp->tnplm;
d944 3
a946 3
    if(exp->tnplm != old_tnplm){
      fprintf(stderr,"sh_compute_plm: error: tnplm initially %i, now %i\n",
	      old_tnplm,exp->tnplm);
d958 2
d986 1
a986 1
  case HEALPIX:
d996 2
a997 2
	*value = (CPREC)-s1 * exp->alm_c[heal_index(&exp->heal,l,m)].di;
      else{
d1000 1
a1000 1
	value[1] = (CPREC)-s1 * exp->alm_c[index].di;
d1002 1
a1002 1
    }else{			/* as is  */
d1005 3
a1007 3
      else if(use_b == 1)
	*value = (CPREC)exp->alm_c[heal_index(&exp->heal,l,m)].di;
      else{
d1009 1
a1009 1
	value[1] =  (CPREC)exp->alm_c[index].di;
d1013 1
a1013 2
  case RICK:
    /* get index */
d1015 2
a1016 2
      if(phys_norm){
	*value = (CPREC)exp->alm[LM_INDEX(l,m,use_b)] * RICK_FACTOR(l,m);
d1018 5
a1022 1
	*value = (CPREC)exp->alm[LM_INDEX(l,m,use_b)];
d1027 1
a1027 1
	s1 = RICK_FACTOR(l,m);
d1029 1
a1029 1
	value[1] = (CPREC)exp->alm[index+1]* s1;
d1032 1
a1032 1
	value[1] = (CPREC)exp->alm[index+1];
d1078 5
d1084 1
a1084 1
  case HEALPIX:
d1111 1
a1111 1
  case RICK:
d1115 1
a1115 1
	  *value / RICK_FACTOR(l,m);
d1118 1
a1118 1
	  value[0] / (s1=RICK_FACTOR(l,m));
d1160 2
a1161 2
  case HEALPIX:			/* nplm should reflect the lmax */
    for(i=0;i < b->nplm;i++){
d1165 1
a1165 1
    for(i=b->nplm;i < a->nplm;i++)
d1168 2
a1169 2
  case RICK:
    for(i=0;i < b->nplm;i++)
d1171 1
a1171 1
    for(i=b->nplm;i < a->nplm;i++)
d1191 1
a1191 1
  case HEALPIX:
d1200 1
a1200 1
  case RICK:
d1219 1
a1219 1
  case HEALPIX:
d1226 1
a1226 1
  case RICK:
@


1.6
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.5 2004/07/01 01:25:28 becker Exp becker $
d35 2
a36 1
if you ever want vector haronics, set ivec to unity
@


1.5
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.4 2004/06/24 01:02:13 becker Exp becker $
d18 2
a19 2
void sh_allocate_and_init(struct lms **exp, int n,int lmax, int type, 
			  int ivec,my_boolean verbose)
d42 1
a42 1
		       int ivec,my_boolean verbose)
d88 1
a88 1
    my_scmplx_vecalloc(&exp->alm_c,exp->nplm,"init_expansion");
d108 1
a108 1
    my_dvecalloc(&exp->alm,exp->nplm,"sh_init_expansion");
d110 1
a110 1
    my_svecalloc(&exp->alm,exp->nplm,"sh_init_expansion");
d119 2
a120 2
    rick_init(&exp->lmax,&ivec,&exp->npoints,
	      &exp->nplm,&exp->tnplm);
d177 1
a177 1
  my_svecalloc(&power,exp->lmaxp1,"sh_power");
d199 1
a199 1
    rick_compute_power(exp->alm,&exp->lmax,power);
d221 2
a222 2
			 FILE *out, my_boolean short_format,
			 my_boolean binary,my_boolean verbose)
d276 1
a276 1
my_boolean sh_read_parameters(int *type, int *lmax, int *shps,
d279 2
a280 2
			      FILE *in, my_boolean short_format,
			      my_boolean binary,my_boolean verbose)
d387 2
a388 2
			   CPREC *fac,my_boolean binary, 
			   my_boolean verbose)
d442 2
a443 2
			  my_boolean binary, CPREC *fac,
			  my_boolean verbose)
d513 2
a514 2
			    my_boolean show_z_label,
			    float z, my_boolean verbose)
d542 1
a542 1
      rick_pix2ang(&j,&exp->lmax,(xp+THETA),(xp+PHI));
d594 2
a595 2
			 my_boolean save_plm,double **plm,
			 struct lms *exp, my_boolean verbose)
d609 1
a609 1
      MY_ERROR("sh_compute_spectral","healpix: ivec==1 not implemented yet");
d637 1
a637 1
      rick_shd2c_pre(data,(data+exp[0].npoints),&exp[0].lmax,
d642 1
a642 1
      rick_shd2c(data,(data+exp[0].npoints),&exp[0].lmax,&ivec,
d674 2
a675 2
			my_boolean save_plm,double **plm,
			float *data, my_boolean verbose)
d678 1
a678 1
    MY_ERROR("sh_compute_spatial","coefficients set not initialized");
d692 1
a692 1
      MY_ERROR("sh_compute_spectral","healpix: ivec==1 not implemented yet");
d709 1
a709 1
      rick_shc2d_pre(exp[0].alm,exp[1].alm,&exp[0].lmax,
d713 1
a713 1
      rick_shc2d(exp[0].alm,exp[1].alm,&exp[0].lmax,&ivec,
d781 1
a781 1
			   float *data, my_boolean show_z_label,
d790 1
a790 1
      MY_ERROR("sh_print_spatial_data","mismatch of npoints for exp set");
d812 1
a812 1
      rick_pix2ang(&j,&exp[0].lmax,(xp+THETA),(xp+PHI));
d852 1
a852 1
		    my_boolean verbose)
d854 1
a854 1
  static my_boolean plm_computed = FALSE;
d860 1
a860 1
    my_dvecrealloc(plm,exp->tnplm,"sh_compute_plm");
d875 2
a876 2
      rick_compute_allplm(&exp->lmax,&ivec,*plm,
			  (*plm+exp->nplm));
d920 1
a920 1
		  my_boolean phys_norm, CPREC *value)
d1009 1
a1009 1
		    int use_b,my_boolean phys_norm, 
@


1.4
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.3 2004/06/23 01:06:56 becker Exp becker $
d383 2
d387 2
a388 1
			   my_boolean binary, my_boolean verbose)
d413 2
a414 1
	  fvalue[0] = (HC_BIN_PREC)value[0];fvalue[1] = (HC_BIN_PREC)value[1];
d422 1
a422 1
	  fprintf(out,"%15.7e %15.7e\t",value[0],value[1]);
d437 1
a437 1
scale coefficients with factor fac
d442 1
a442 1
			  my_boolean binary, CPREC fac,
d492 2
a493 5

  if(fac != 1.0){
    for(j=0;j<shps;j++)
      sh_scale_expansion((exp+j),fac);
  }
d975 1
a975 1
	*value = (CPREC)exp->alm[LM_INDEX(l,m,use_b)]*RICK_FACTOR(l,m);
d980 1
d982 2
a983 1
	value[0] = (CPREC)exp->alm[(index=LM_INDEX(l,m,0))]  * (s1=RICK_FACTOR(l,m));
d986 1
a986 1
	value[0] = (CPREC)exp->alm[(index=LM_INDEX(l,m,0))];
d1142 1
a1142 1
    for(l=0;l < exp->lmax;l++){
d1146 1
a1146 1
	exp->alm_c[index].di * fac;
d1151 1
a1151 1
    for(l=0;l < exp->lmax;l++){
d1170 5
a1174 4
    for(l=0;l < exp->lmax;l++)for(m=0;m <= l;m++){
      exp->alm_c[(index = heal_index(&exp->heal,l,m))].dr * fac;
      exp->alm_c[index].di * fac;
    }
d1177 5
a1181 4
    for(l=0;l < exp->lmax;l++)for(m=0;m <= l;m++){
      exp->alm[(index = LM_INDEX(l,m,0))] *= fac;
      exp->alm[index+1] *= fac;
    }
@


1.3
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.2 2004/06/21 01:16:31 becker Exp becker $
d220 3
a222 2
			 int ilayer, int nset,float zlabel,
			 FILE *out, my_boolean verbose)
d224 2
d232 26
a257 4
  fprintf(out,"%6i %6i %11g %6i %2i %2i ",
	  exp[0].lmax,ilayer+1,zlabel,nset,
	  shps,exp[0].type);
  /* additional parameters? */
d267 2
a268 1
  fprintf(out,"\n");		/* finish header line */
d278 7
a284 3
			      float *zlabel,int *ivec,
			      FILE *in, my_boolean verbose)
{
d291 34
a324 3
  if(fscanf(in,"%i %i %f %i %i %i ",
	    lmax,ilayer,zlabel,nset,shps,type)!=6)
    return FALSE;
d330 3
a332 1
  /* additional parameters? */
d385 1
a385 1
			   my_boolean verbose)
d389 1
d405 20
a424 13
  for(l=0;l <= exp[0].lmax;l++){
    for(m=0;m <= l;m++){
      for(j=0;j < shps;j++){
	/* 
	   get the coefficients
	*/
	sh_get_coeff((exp+j),l,m,2,TRUE,value);
	fprintf(out,"%15.7e %15.7e\t",value[0],value[1]);
      }
      fprintf(out,"\n");
    } /* end m loop */
  }	/* end l loop */
  fprintf(out,"\n");
d431 5
d438 1
d443 1
d459 27
a485 7
  for(l=0;l <= exp[0].lmax;l++){
    for(m=0;m <= l;m++){
      for(j=0;j < shps;j++){
	if(fscanf(in,"%lf %lf",value,(value+1))!=2){
	  fprintf(stderr,"sh_read_coefficients: read error: set %i l %i m %i\n",
		  j+1,l,m);
	  exit(-1);
d487 6
a492 6
	/* read in real, Dahlen & Tromp normalized coefficients and convert
	   to whatever format we are using internally */
	sh_write_coeff((exp+j),l,m,2,TRUE,value);
      }
    } /* end m loop */
  }	/* end l loop */
d1161 22
@


1.2
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_exp.c,v 1.1 2004/06/16 02:06:33 becker Exp becker $
a365 5
  if((shps != 1)&&(shps != 3)){
    fprintf(stderr,"sh_read_coefficients: error: shsp %i out of range\n",
	    shps);
    exit(-1);
  }
d389 2
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
$Id: shexp.c,v 1.1 2004/06/05 00:03:10 becker Exp becker $
d12 1
a12 1
#include "hcexp.h"
d14 3
a16 1
   free an expansion structure 
d18 2
a19 1
void free_expansion(struct lms *exp,int ivec)
d21 6
a26 13
  switch(exp->type){
  case HEALPIX:			/* HEALPIX part */
    heal_free_structure(&exp->heal);
    free(exp->alm_c);
    break;
  case RICK:
    free(exp->alm);
    rick_free_module(&ivec);
    break;
  default:
    exp_type_error("free_expansion",exp);
    break;
  }
d28 1
d33 1
a33 3
depends on the type of expansion. this can be used for scalar, or for
poloidal/toroidal. in this case, two expansions will need to be
initialized
d35 1
a35 2
if type == HEALPIX:
            nside and order are used
d37 1
a37 2
            nside: order of spatial representation
            order: ordering, HEALPIX_RING or HEALPIX_NEST
a38 3
it type == RICK:
         
            no other parameters
d41 2
a42 3
void init_sh_expansion(struct lms *exp, int lmax, int type, 
		       int ivec,int nside,int order,
		       my_boolean verbose)
d50 1
d55 1
a55 1
    fprintf(stderr,"init_sh_expansion: error: lmax out of bounds: %i\n",
d59 1
d89 2
a90 1
    /* 
d94 2
a95 1
    heal_init_parameters(&exp->heal,nside,order,ivec,exp->lmax,&exp->npoints,
d108 1
a108 1
    my_dvecalloc(&exp->alm,exp->nplm,"init_expansion");
d110 1
a110 1
    my_svecalloc(&exp->alm,exp->nplm,"init_expansion");
d112 2
d123 80
a202 1
    exp_type_error("init_expansion",exp);
d208 77
d297 7
d314 5
a318 2
   pass shps as unity, if scalar, else as 3 if u_r pol tor 
   components with three expansions for velocity field
d321 1
a321 1
void print_sh_coefficients(struct lms *exp, int shps, FILE *out, 
d325 1
a325 5
  if((shps != 1)&&(shps != 3)){
    fprintf(stderr,"print_sh_coefficients: error: shsp %i out of range\n",
	    shps);
    exit(-1);
  }
d331 2
a332 2
      fprintf(stderr,"print_sh_coefficients: error: lmax(%i):%i != lmax(0):%i\n",
	      j+1,model->exp[j].lmax,model->exp[0].lmax);
d336 1
a336 1
      fprintf(stderr,"print_sh_coefficients: error: type(%i):%i != type(0):%i\n",
d347 1
a347 1
	get_coeff((exp+j),l,m,2,TRUE,value);
d356 44
d416 1
a416 1
void print_sh_spatial_basis(struct lms *exp, FILE *out, 
d438 1
a438 1
	fprintf(stderr,"print_sh_spatial_basis: error: ordering %i undefined\n",
d449 1
a449 1
      exp_type_error("print_sh_spatial_basis",exp);
d497 1
a497 1
void compute_sh_spectral(float *data, int ivec,
d507 1
a507 1
    compute_plm((exp+0),ivec,plm,verbose); 
d513 1
a513 2
      fprintf(stderr,"compute_sh_spectral: healpix: ivec==1 not implemented yet\n");
      exit(-1);
d550 1
a550 1
    exp_type_error("compute_sh_spectral",exp);
d577 1
a577 1
void compute_sh_spatial(struct lms *exp, int ivec,
d581 2
a582 4
  if((!exp[0].spectral_init)||(ivec && !exp[1].spectral_init)){
    fprintf(stderr,"compute_sh_spatial: error: coefficients set not initialized\n");
    exit(-1);
  }
d591 1
a591 1
    compute_plm((exp+0),ivec,plm,verbose); 
d596 1
a596 2
      fprintf(stderr,"compute_sh_spectral: healpix: ivec==1 not implemented yet\n");
      exit(-1);
d622 1
a622 1
    exp_type_error("compute_sh_spatial",exp);
d632 1
a632 1
void exp_type_error(char *subroutine,struct lms *exp)
d643 2
a644 2
void print_plm(double *plm, int nplm, int ivec, int type,
	       FILE *out)
d665 1
a665 1
    fprintf(stderr,"print_plm: expansion type %i undefined\n",
d684 1
a684 1
void print_sh_spatial_data(struct lms *exp, int ivec, 
d693 2
a694 4
       (exp[2].npoints != exp[0].npoints)){
      fprintf(stderr,"print_sh_spatial_data: mismatch of npoints for exp set\n");
      exit(-1);
    }
d719 1
a719 1
      exp_type_error("print_sh_spatial_data",exp);
d755 2
a756 2
void compute_plm(struct lms *exp,int ivec,double **plm,
		 my_boolean verbose)
d764 1
a764 1
    my_dvecrealloc(plm,exp->tnplm,"compute_plm");
d771 1
a771 1
	fprintf(stderr,"compute_plm: healpix: computing Plm for lmax %i\n",
d777 1
a777 1
	fprintf(stderr,"compute_plm: Rick: computing all Plm for lmax %i\n",
d783 1
a783 1
      exp_type_error("compute_plm",exp);
d797 1
a797 1
      fprintf(stderr,"compute_plm: error: lmax initially %i, now %i\n",
d803 2
a804 2
      fprintf(stderr,"compute_plm: error: plm are to be saved but routine was initialized\n");
      fprintf(stderr,"compute_plm: error: with ivec: %i and now we want vectors, ivec: %i\n",
d809 1
a809 1
      fprintf(stderr,"compute_plm: error: tnplm initially %i, now %i\n",
d823 2
a824 2
void get_coeff(struct lms *exp,int l, int m, int use_b, 
	       my_boolean phys_norm, CPREC *value)
a826 1
  static int izero = 0;
d829 18
a852 2

    index = heal_index(&exp->heal,l,m);
d856 1
a856 1
	*value = (CPREC) s1 * exp->alm_c[index].dr;
d858 1
a858 1
	*value = (CPREC)-s1 * exp->alm_c[index].di;
d860 2
a861 1
	value[0] = (CPREC) s1 * exp->alm_c[index].dr;
d866 1
a866 1
	*value = (CPREC)exp->alm_c[index].dr;
d868 1
a868 1
	*value = (CPREC)exp->alm_c[index].di;
d870 1
a870 1
	value[0] =  (CPREC)exp->alm_c[index].dr;
a877 1
      rick_index(&l,&m,&use_b,&index);
d879 1
a879 1
	*value = (CPREC)exp->alm[index]*RICK_FACTOR(l,m);
d881 1
a881 1
	*value = (CPREC)exp->alm[index];
a883 1
      rick_index(&l,&m,&izero,&index);
d885 1
a885 1
	value[0] = (CPREC)exp->alm[index]  * (s1=RICK_FACTOR(l,m));
d888 1
a888 1
	value[0] = (CPREC)exp->alm[index];
d894 1
a894 1
    exp_type_error("print_sh_coefficients",exp);
d910 3
a912 2
void write_coeff(CPREC *value,struct lms *exp,int l, int m, 
		 int use_b,my_boolean phys_norm)
a914 1
  static int izero = 0;
d917 18
d966 2
a967 2
	rick_index(&l,&m,&use_b,&index);
	exp->alm[index] = *value / RICK_FACTOR(l,m);
d969 2
a970 2
	rick_index(&l,&m,&izero,&index);
	exp->alm[index]   = value[0] / (s1=RICK_FACTOR(l,m));
d975 1
a975 2
	rick_index(&l,&m,&use_b,&index);
	exp->alm[index] = *value;
d977 1
a977 2
	rick_index(&l,&m,&izero,&index);
	exp->alm[index]   = value[0];
d983 1
a983 1
    exp_type_error("print_sh_coefficients",exp);
d987 79
@
