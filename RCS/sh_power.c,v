head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.24.02.09.00;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.23.02.39.57;	author becker;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@#include "hc.h"

/* 

read in a spherical harmonic expansion in  Dahlen and Tromp normalization 
and computer power per degree and unit area

Thorsten Becker (twb@@usc.edu)


usage: cat ab.sh_ana | sh_power [short_format, 0]

if short format is 0, will expect 

  type lmax shps ilayer nset zlabel ivec
  A-00 B-00
  A-10 B-10
  ...

format. if short format is set, will expect 

  lmax 
  A-00 B-00
  A-10 B-10
  ...

format



$Id: sh_power.c,v 1.4 2004/12/20 05:09:42 becker Exp becker $

*/

int main(int argc, char **argv)
{
  int type,lmax,shps,ilayer,nset,ivec,i,l;
  hc_boolean verbose = TRUE, short_format = FALSE ,binary = FALSE;
  float *power = NULL;
  HC_PREC fac[3] = {1.,1.,1.},zlabel;
  struct sh_lms *exp;
  if(argc>1){
    sscanf(argv[1],"%i",&i);
    if(i)
      short_format = TRUE;
  }
  fprintf(stderr,"%s: awaiting spherical harmonics expansion (%s) from stdin\n",
	  argv[0],short_format ? "short format" : "long format");
  while(sh_read_parameters(&type,&lmax,&shps,&ilayer,&nset,
			   &zlabel,&ivec,stdin,short_format,
			   binary,verbose)){
    fprintf(stderr,"%s: computing power per degree and unit area for lmax %i ivec: %i at z: %g\n",
	    argv[0],lmax,ivec,zlabel);
    /* 
       input and init 
    */
    sh_allocate_and_init(&exp,shps,lmax, type,ivec,verbose);
    sh_read_coefficients(exp,shps,-1,stdin,binary,fac,verbose);
    /* get space */
    hc_svecrealloc(&power,exp->lmaxp1 * shps,"sh_power");
    /* compute the powers */
    for(i=0;i<shps;i++)
      sh_compute_power_per_degree((exp+i),(power+i*exp->lmaxp1));
    for(l=0;l<=exp->lmax;l++){
      fprintf(stdout,"%5i ",l);
      for(i=0;i<shps;i++)
	fprintf(stdout,"%15.7e",power[l+i*exp->lmaxp1]);
      fprintf(stdout,"\n");
    }
    free(exp);
  }
  return 0;
}
@


1.4
log
@*** empty log message ***
@
text
@d31 1
a31 1
$Id: sh_power.c,v 1.3 2004/12/01 01:25:35 becker Exp becker $
d40 1
a40 2
  HC_CPREC fac[3] = {1.,1.,1.},zlabel;
  double *dbl_dummy;
@


1.3
log
@*** empty log message ***
@
text
@d31 1
a31 1
$Id: sh_power.c,v 1.2 2004/11/24 02:09:00 becker Exp becker $
d42 1
a42 1
  struct lms *exp;
@


1.2
log
@*** empty log message ***
@
text
@d31 1
a31 1
$Id: sh_power.c,v 1.1 2004/11/23 02:39:57 becker Exp becker $
d40 1
a40 1
  CPREC fac[3] = {1.,1.,1.},zlabel;
d59 1
a59 1
    sh_read_coefficients(exp,shps,stdin,binary,fac,verbose);
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
usage: cat ab.sh_ana | sh_power
d13 1
d15 4
d20 12
a31 1
$Id: sh_ana.c,v 1.1 2004/08/06 00:38:36 becker Exp becker $
d37 5
a41 1
  int type = SH_RICK,lmax,shps,nset=1,ivec,i,ilayer=0;
d43 4
a46 26
  hc_boolean verbose = TRUE, use_3d = FALSE, short_format = FALSE,
    binary = FALSE, print_spatial_base = FALSE;
  float *data, zlabel = 0,*flt_dummy;
  double *dbl_dummy;
  CPREC fac[3] = {1.,1.,1.};

  /* 
     default values 
  */
  ivec=0;
  if(argc > 1){
    sscanf(argv[1],"%i",&lmax);
    if(lmax < 0){
      print_spatial_base = TRUE;
      lmax = -lmax;
    }
  }
  if(argc > 2)
    sscanf(argv[2],"%i",&ivec);
  if((argc > 3)||(argc<=1)){
    fprintf(stderr,"usage: %s l_max [ivec]\n",argv[0]);
    fprintf(stderr,"       l_max: max order of expansion. if negative, will print out the spatial\n");
    fprintf(stderr,"                 locations needed on input\n\n");
    fprintf(stderr,"       ivec:  0: expand scalar field\n");
    fprintf(stderr,"              1: expand vector field\n\n");
    exit(-1);
d48 7
a54 13
  if(print_spatial_base)
    fprintf(stderr,"%s: printing spatial base for lmax: %i\n",
	    argv[0],lmax);
  else
    fprintf(stderr,"%s: expanding to lmax: %i, expecting %s\n",
	    argv[0],lmax,(ivec)?("lon lat vt vp"):("lon lat x"));
  /* select numbers of expansions */
  shps = (ivec)?(2):(1);
  /* intialize expansion first */
  sh_allocate_and_init(&exp,shps*nset,lmax,type,ivec,verbose);
  /* make room for data */
  hc_svecalloc(&data,shps * exp->npoints,"sh_ana");
  if(print_spatial_base){
d56 1
a56 1
       print out spatial basis 
d58 14
a71 19
    sh_compute_spatial_basis(exp,stdout,use_3d,zlabel,&flt_dummy,0,verbose);
  }else{
    /* 
       perform spherical harmonic analysis
    */
    /* read in data from stdin */
    sh_read_spatial_data(exp,stdin,use_3d,shps,data,&zlabel);
    /* 
       perform spherical harmonic expansion 
    */
    sh_compute_spectral(data,ivec,FALSE,&dbl_dummy,
			exp,verbose);
    /* print parameters of expansion */
    sh_print_parameters(exp,shps,ilayer,nset,zlabel,
			stdout,short_format,binary,
			verbose);
    /* print coefficients */
    sh_print_coefficients(exp,shps,stdout,fac,binary, 
			  verbose);
a72 1
  free(exp);free(data);
@
