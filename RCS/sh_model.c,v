head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.24.02.09.00;	author becker;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.06.00.38.36;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.02.00.14.44;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.01.01.25.28;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.24.01.02.13;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.21.01.16.31;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.16.02.06.30;	author becker;	state Exp;
branches;
next	;


desc
@@


1.11
log
@*** empty log message ***
@
text
@/* 


routines to handle models with several spherical harmonics expansions

the lower level routines that operate on single (or triple) 
sets of expansions are in sh_exp.c

$Id: sh_model.c,v 1.10 2004/12/20 05:18:12 becker Exp becker $

*/
#include "hc.h"
/* 
   
initialize a model structure that may hold several spherical harmonics
expansions

input:

model structure (holds all the expansion)

input:

lmax: max order of expansions
type: type of expansion (SH_RICK, SH_HEALPIX,...)
nset: number of spherical harmonic sets
ivec: 0: scalar expansion, one SH expansion per set
      1: u-r u-theta u-phi vector field, three expansions per set


for SH_HEALPIX:
nside: order of skymap
order: sorting order of skymap


*/
void sh_init_model(struct sh_lms_model *model,int lmax,int type,
		   int nset, int ivec, int nside, int order, 
		   hc_boolean verbose)
{
  int i;
  if(nset <= 0){
    fprintf(stderr,"sh_init_model: error: nset (%i) out of bounds\n",
	    nset);
    exit(-1);
  }
  model->nset = nset;
  if((ivec<0)||(ivec>1)){
    fprintf(stderr,"sh_init_model: error: ivec (%i) out of bounds\n",
	    ivec);
    exit(-1);
  }
  model->ivec = ivec;		/* is vector expansion? */
  if(model->ivec==1)/* SH expansions per set */
    model->shps = 3;		/* spectrally:
				   u_r poloidal toroidal
				   spatially:
				   u_r u_theta u_phi 
				*/
  else
    model->shps = 1;
  /* 
     initialize expansions 
  */
  model->nexp = model->shps * model->nset; 
  model->exp = (struct sh_lms *)
    calloc(model->nexp,sizeof(struct sh_lms));
  if(!model->exp)
    HC_MEMERROR("sh_init_model");
  model->tnpoints = 0;
  for(i=0;i < model->nexp;i++){	/* initialize expansions and add 
				   up total number of points 
				   in spatial domain
				*/
    sh_init_expansion((model->exp+i),lmax,type,model->ivec,
		      verbose);
    model->tnpoints += model->exp[i].npoints;
  }
  /* logic  flag for spatial data */
  model->spatial_init = FALSE;
  /* should we attempt to precompute and store legendre factors? */
  if((type == SH_RICK)||(type == SH_HEALPIX))
    model->save_plm = TRUE;
  else
    model->save_plm = FALSE;
  /* will be allocated later */
  model->plm = NULL;
  for(i=1;i < model->nexp;i++) 
    /* check if all expansisons are the
       same type so that we need only
       one Plm array 
    */
    if(model->exp[i].tn_plm != model->exp[0].tn_plm)
      HC_ERROR("init_sh_model","tnplm mismatch");
  /* 
     layer indicator attributes 
  */
  model->z = (float *)calloc(model->nset,sizeof(float));
  if(!model->z)
    HC_MEMERROR("sh_init_model: z");
  /* 
     data pointer, initialize as NULL
  */
  model->data = NULL;
  model->initialized = TRUE;
}
/* 
   free a model structure 
*/
void sh_free_model(struct sh_lms_model *model)
{
  free(model->z);
  sh_free_expansion(model->exp,model->nexp);
  if(model->save_plm)
    free(model->plm);
}
/* 

write the coefficients of a spherical harmonic expansion to out stream

output will be real spherical harmonics coefficients as in Dahlen and
Tromp p. 859

for vec = 0, then output is in format

   lmax i z_i nset 1 type_parameters
   
   A00 B00
   A10 B10
   A11 B11
   A20 ...

and so on, for each layer i (1..nset) of nset sets. 
if ntype=3, the coefficients will be 

   lmax i z_i nset 3 type_parameters

   A00_s B00_s   A00_p B00_p    A00_t B00_t
   A10_s B10_s   A10_p B10_p    A10_t B10_t
   ....

where s, p, and t are the scalar (radial), poloidal, and toroidal expansions, 
respectively

type_parameters is:

type parameters

where type can be SH_HEALPIX (0) or SH_RICK(1) and then the parameters 
depend on the type of expansion

z_i is the label for this set

*/
void sh_print_model_coefficients(struct sh_lms_model *model, 
				 FILE *out,hc_boolean binary,
				 hc_boolean verbose)
{
  int i;
  HC_CPREC *fac;
  hc_vecalloc(&fac,model->shps,"sh_print_model_coefficients");
  for(i=0;i<model->shps;i++)
    fac[i] = 1.0;
  for(i=0;i < model->nexp;i++)	/* check all expansions */
    if(!model->exp[i].spectral_init)
      HC_ERROR("sh_print_model_coefficients","coefficients not initialized expansion");
  for(i = 0; i < model->nset;i++){	/* loop through sets */
    /* output of parameters */
    sh_print_parameters((model->exp+i*model->shps),
			model->shps,i,model->nset,
			model->z[i],out,FALSE,binary,verbose);
    /* output of coefficient(s) (1 (ivec=0) or 3 (ivec=1)) */
    sh_print_coefficients((model->exp+i*model->shps), 
			  model->shps,out,fac,binary,verbose);
  } /* end set loop */
  free(fac);
}
/* 
   
write the coordinates of the spatial basis of a model including
possibly several spherical harmonics expansion. if nset==1, the format is 

lon lat

if nset != 1, the format is 

lon lat z

if z has been read in, else it's zero


*/
void sh_print_model_spatial_basis(struct sh_lms_model *model, 
				  FILE *out, 
				  hc_boolean verbose)
{
  int i;
  float **flt_dummy=NULL;
  if(verbose)
    fprintf(stderr,"sh_print_model_spatial_basis: printing spatial basis for nset %i expansions\n",
	    model->nset);
  for(i=0;i < model->nset;i++)
    sh_compute_spatial_basis((model->exp+i*model->shps),out,
			     (model->nset==1)?(FALSE):(TRUE),
			     model->z[i],flt_dummy,0,verbose);
}
/*

   read in lon lat data tripels at all spatial basis point location of
   the spherical harmonic expansions

   if model.nset == 1:
   
   reads lon lat data from stream "in"

   if model.nset != 1:

   read lon lat z data from stream "in"


   data is either a scalar, or u_r u_theta u_phi for 
   model.ivec == 1
   
   input:  model parameter, including nset and ivec
   output: data, will be dimnesionalized exp->npoints * exp->nset

   data has to be initialized, eg. as NULL
   
*/
void sh_read_model_spatial_data(struct sh_lms_model *model, 
				float **data,FILE *in,
				hc_boolean verbose)
{
  int i,j;
  /* 
     make room for the spatial data
  */
  fprintf(stderr,"sh_read_model_spatial_data: reading %i sets, expecting %s locations and %s data\n",
	  model->nset,(model->nset == 1)?("lon lat"):("lon lat z"),
	  (model->ivec==1)?("u_r u_theta u_phi"):("scalar"));
  /* 
     allocate space for all the data points
  */
  hc_svecrealloc(data, model->tnpoints,
		 "sh_read_model_spatial_data");
  /* 
     check all sets, number of points have to be the same for each
     expansion
  */
  for(i=0;i<model->nset;i++)
    for(j=((i==0)?(1):(0));j<model->shps;j++){
      if(model->exp[i*model->shps+j].npoints != 
	 model->exp[0].npoints){
	fprintf(stderr,"sh_read_model_spatial_data: error: set %i expansion %i out of %i: npoints: %i npoints(0): %i\n",
		i+1,j+1,model->shps,
		model->exp[i*model->shps+j].npoints,
		model->exp[0].npoints);
	exit(-1);
      }
    }
  for(i=0;i < model->nset;i++)
    /* read in the data for this layer */
    sh_read_spatial_data((model->exp+i*model->shps),in,(model->nset!=1)?(TRUE):(FALSE),
			 model->shps,
			 (*data+model->shps*model->exp[i*model->shps].npoints),
			 (model->z+i));
  model->spatial_init = TRUE;
}

/* 
   compute the spherical harmonic expansion of a model with
   several sets. this calls the spherical harmonics routines
   
*/
void sh_compute_model_spectral(struct sh_lms_model *model,
			       float *data,
			       hc_boolean verbose)
{
  int i;
  static int unity = 1,zero = 0;
  if(!model->spatial_init)
    HC_ERROR("sh_compute_model_spectral","spatial set not initialized");
  if(((model->ivec)&&(model->shps != 3))||
     ((!model->ivec)&&(model->shps != 1))){
    fprintf(stderr,"sh_compute_model_spectral: error: ivec: %i nshp: %i\n",
	    model->ivec,model->shps);
    exit(-1);
  }
  for(i=0;i < model->nset;i++){	/* loop through sets */
    if(model->ivec == 1){
      /* 
	 first call for theta, phi components 
	 to assign poloidal and toroidal part
      */
      sh_compute_spectral((data+model->exp[i*model->shps+0].npoints), 
			  unity,model->save_plm,&model->plm,
			  (model->exp+i*model->shps+1), 
			  verbose);
      /* then the u_r scalar components, which is the first 
	 expansion */
      sh_compute_spectral(data,zero,model->save_plm,&model->plm,
			  (model->exp+i*model->shps+0), 
			  verbose);
    }else{
      /* scalar expansion */
      sh_compute_spectral(data,zero,model->save_plm,&model->plm,
			  (model->exp+i),verbose);
    }
  }
}
/* 
   
expand the coefficients of a model into the spatial space
pass data initialized at least at NULL

*/
void sh_compute_model_spatial(struct sh_lms_model *model,
			      float **data,hc_boolean verbose)
{
  int i;
  static int unity = 1, zero = 0;
  /* 
     resize data
  */
  if(verbose)
    fprintf(stderr,"sh_compute_model_spatial: computing %i spatial points, type %i\n",
	    model->tnpoints,model->exp[0].type);
  /* 
     make room for data 
  */
  hc_svecrealloc(data,model->tnpoints,"sh_compute_model_spatial");
  if(((model->ivec)&&(model->shps != 3))||
     ((!model->ivec)&&(model->shps != 1))){
    fprintf(stderr,"sh_compute_model_spatial: error: ivec: %i nshp: %i\n",
	    model->ivec,model->shps);
    exit(-1);
  }
  for(i=0;i < model->nset;i++){
    if(model->ivec == 1){
      /* 
	 first call for theta, phi components from poloidal and
	 toroidal expansions
      */
      sh_compute_spatial((model->exp+i*model->shps+1), 
			 unity,model->save_plm,&model->plm,
			 (*data+model->exp[i*model->shps+0].npoints),
			 verbose);
      /* then the u_r scalar expansion */
      sh_compute_spatial((model->exp+i*model->shps+0),
			 zero,model->save_plm,&model->plm,
			 *data,verbose);
    }else{
      /* scalar expansion */
      sh_compute_spatial((model->exp+i*model->shps),zero,
			 model->save_plm,&model->plm,
			 *data,verbose);
    }
  }
}
/* 
  
print a whole model of spatial data with different levels

*/
void sh_print_model_spatial_data(struct sh_lms_model *model,
				 float *data, FILE *out,
				 hc_boolean verbose)
{
  int i,j,os;
  os = 0;
  for(i=0;i < model->nset;i++){
    /* print out data for the set */
    sh_print_spatial_data((model->exp+i*model->shps),
			  (model->ivec)?(3):(1),(data+os),
			  (model->nset == 1)?(FALSE):(TRUE),
			  model->z[i],out);
    if(model->ivec)
      for(j=0;j<3;j++)
	os += model->exp[i*model->shps+j].npoints;
    else
      os += model->exp[i*model->shps+0].npoints;
  }
}
@


1.10
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.9 2004/12/20 05:09:42 becker Exp becker $
d160 1
a160 1
  CPREC *fac;
@


1.9
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.8 2004/12/01 01:25:35 becker Exp becker $
d159 1
a159 1
  int l,m,i,j;
d198 1
a198 1
  float **flt_dummy;
@


1.8
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.7 2004/11/24 02:09:00 becker Exp becker $
d37 1
a37 1
void sh_init_model(struct lms_model *model,int lmax,int type,
d66 2
a67 2
  model->exp = (struct lms *)
    calloc(model->nexp,sizeof(struct lms));
d110 1
a110 1
void sh_free_model(struct lms_model *model)
d155 1
a155 1
void sh_print_model_coefficients(struct lms_model *model, 
d193 1
a193 1
void sh_print_model_spatial_basis(struct lms_model *model, 
d230 1
a230 1
void sh_read_model_spatial_data(struct lms_model *model, 
d275 1
a275 1
void sh_compute_model_spectral(struct lms_model *model,
d317 1
a317 1
void sh_compute_model_spatial(struct lms_model *model,
d365 1
a365 1
void sh_print_model_spatial_data(struct lms_model *model,
@


1.7
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.6 2004/08/06 00:38:36 becker Exp becker $
d69 1
a69 1
    MEMERROR("sh_init_model");
d100 1
a100 1
    MEMERROR("sh_init_model: z");
a111 1
  int i;
d113 1
a113 2
  for(i=0;i < model->nexp;i++)
    sh_free_expansion((model->exp+i));
@


1.6
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.5 2004/07/02 00:14:44 becker Exp becker $
d236 1
a236 2
  int i,j,os[3];
  double xp[3],lon,lat;
d246 1
a246 1
  hc_svecrealloc(&model->data, model->tnpoints,
d263 6
a268 111
  for(os[0]=i=0;i < model->nset;i++){
    if(model->ivec){		/* offsets if more than a scalar are
				   to be read in  */
      os[1] = os[0] + model->exp[i*model->shps+0].npoints;
      os[2] = os[1] + model->exp[i*model->shps+1].npoints;
    }
    /* 
       read in data for each layer 
    */
    for(j=0;j < model->exp[i*model->shps].npoints;j++){
      /* 
	 get expected coordinates to check if the input is OK
      */
      switch(model->exp[i*model->shps].type){
      case SH_HEALPIX:
	switch(model->exp[i*model->shps].heal.ordering){
	case SH_HEALPIX_RING:  
	  pix2ang_ring((long)model->exp[i*model->shps].heal.nside,(long)j,
		       (xp+THETA),(xp+PHI));
	  break;
	case SH_HEALPIX_NEST:  
	  pix2ang_nest((long)model->exp[i*model->shps].heal.nside,(long)j,
		       (xp+THETA),(xp+PHI));
	  break;
	default:
	  fprintf(stderr,"sh_read_model_spatial_basis: error: ordering %i undefined\n",
		  model->exp[i*model->shps].heal.ordering);
	  exit(-1);
	  break;
	}
	break;			/* end Healpix branch */
      case SH_RICK:
	/* for Rick's type routine */
	rick_f90_pix2ang(&j,&model->exp[i*model->shps].lmax,(xp+THETA),(xp+PHI));
	break;
      default:
	sh_exp_type_error("sh_read_model_spatial_data",(model->exp+i*model->shps));
	break;
      }	/* end type branch */
      /* read coordinates */
      if(model->nset == 1){
	/* 
	   read in lon lat  
	*/
	if(fscanf(in,"%lf %lf",&lon,&lat) != 2){
	  fprintf(stderr,"sh_read_model_spatial_data: error: lon lat format: pixel %i: read error\n",
		  (int)j);
	  exit(-1);
	}
      }else{
	/* 
	   read in lon lat z[i] 
	*/
	if(fscanf(in,"%lf %lf %f",&lon,&lat,&model->z[i]) != 3){
	  fprintf(stderr,"sh_read_model_spatial_data: error: lon lat z format: set %i: pixel %i: read error\n",
		  (int)i,(int)j);
	  exit(-1);
	}
      }
      /* 
	 read data 
      */
      if(model->ivec == 0){	/* 
				   scalar 
				*/
	if(fscanf(in,"%f",(*data+os[0]+j))!=1){
	  fprintf(stderr,"sh_read_model_spatial_data: error: scalar format: set %i: pixel %i: read error\n",
		  (int)i,(int)j);
	  exit(-1);
	}
      }else{			/* 
				   velocities in
				   
				   u_r u_theta u_phi

				*/
	if(fscanf(in,"%f %f %f",(*data+os[0]+j),
		  (*data+os[1]+j),(*data+os[2]+j)) != 3){
	  fprintf(stderr,"sh_read_model_spatial_data: error: velocity format: set %i: pixel %i: read error\n",
		  (int)i,(int)j);
	  exit(-1);
	}
      }
      /* 
	 adjust longitude range 
      */
      if(lon < 0)
	lon += 360.0;
      /* 
	 check if location is OK (we don't know about z defaults) 
      */
      if((fabs(PHI2LON(xp[PHI])-lon) > 1e-3)||
	 (fabs(THETA2LAT(xp[THETA])-lat) > 1e-3)){
	fprintf(stderr,"sh_read_model_spatial_data: error: set: %i: pixel %i coordinate mismatch:\n",
		(int)i,(int)j);
	fprintf(stderr,"sh_read_model_spatial_data: orig: %g, %g file: %g, %g\n",
		PHI2LON(xp[PHI]),THETA2LAT(xp[THETA]),lon,lat);
	exit(-1);
      }
    }	/* end points in layer loop */
    if(verbose)		/* echo input */
      for(j=0;j < model->shps;j++)
	fprintf(stderr,"sh_read_model_spatial_data: read set %3i, %6i points, avg type %i: %11g\n",
		i,model->exp[i*model->shps+j].npoints,j+1,
		hc_mean_svec((*data+os[j]),
			  model->exp[i*model->shps+j].npoints));
    
    /* increment data pointer */
    for(j=0;j < model->shps;j++)
      os[0] += model->exp[i*model->shps+j].npoints;
  } /* end set loop */
@


1.5
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.4 2004/07/01 01:25:28 becker Exp becker $
d25 1
a25 1
type: type of expansion (RICK, HEALPIX,...)
d31 1
a31 1
for HEALPIX:
d82 1
a82 1
  if((type == RICK)||(type == HEALPIX))
d93 1
a93 1
    if(model->exp[i].tnplm != model->exp[0].tnplm)
d151 1
a151 1
where type can be HEALPIX (0) or RICK(1) and then the parameters 
d200 1
d205 3
a207 3
    sh_print_spatial_basis((model->exp+i*model->shps),out,
			   (model->nset==1)?(FALSE):(TRUE),
			   model->z[i],verbose);
d278 1
a278 1
      case HEALPIX:
d280 1
a280 1
	case HEALPIX_RING:  
d284 1
a284 1
	case HEALPIX_NEST:  
d295 1
a295 1
      case RICK:
d436 3
d482 1
a482 1
			  model->ivec,(data+os),
@


1.4
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.3 2004/06/24 01:02:13 becker Exp becker $
d39 1
a39 1
		   my_boolean verbose)
d94 1
a94 1
      MY_ERROR("init_sh_model","tnplm mismatch");
d158 2
a159 2
				 FILE *out,my_boolean binary,
				 my_boolean verbose)
d163 1
a163 1
  my_vecalloc(&fac,model->shps,"sh_print_model_coefficients");
d168 1
a168 1
      MY_ERROR("sh_print_model_coefficients","coefficients not initialized expansion");
d197 1
a197 1
				  my_boolean verbose)
d233 1
a233 1
				my_boolean verbose)
d246 1
a246 1
  my_svecrealloc(&model->data, model->tnpoints,
d296 1
a296 1
	rick_pix2ang(&j,&model->exp[i*model->shps].lmax,(xp+THETA),(xp+PHI));
d367 1
a367 1
		mean_svec((*data+os[j]),
d384 1
a384 1
			       my_boolean verbose)
d389 1
a389 1
    MY_ERROR("sh_compute_model_spectral","spatial set not initialized");
d425 1
a425 1
			      float **data,my_boolean verbose)
d435 1
a435 1
  my_svecrealloc(data,model->tnpoints,"sh_compute_model_spatial");
d471 1
a471 1
				 my_boolean verbose)
@


1.3
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.2 2004/06/21 01:16:31 becker Exp becker $
d162 4
d176 1
a176 1
			  model->shps,out,binary,verbose);
d178 1
@


1.2
log
@*** empty log message ***
@
text
@d9 1
a9 1
$Id: sh_model.c,v 1.1 2004/06/16 02:06:30 becker Exp becker $
d158 1
a158 1
				 FILE *out,
d169 1
a169 1
			model->z[i],out,verbose);
d172 1
a172 1
			  model->shps,out,verbose);
d191 2
a192 1
				  FILE *out, my_boolean verbose)
d227 1
a227 1
				float **data,FILE *in, 
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
$Id: shexp.c,v 1.1 2004/06/05 00:03:10 becker Exp becker $
d12 1
a12 1
#include "hcexp.h"
d37 1
a37 1
void init_sh_model(struct lms_model *model,int lmax,int type,
d43 1
a43 1
    fprintf(stderr,"init_sh_model: error: nset (%i) out of bounds\n",
d49 1
a49 1
    fprintf(stderr,"init_sh_model: error: ivec (%i) out of bounds\n",
d69 1
a69 1
    MEMERROR("init_sh_model");
d75 2
a76 2
    init_sh_expansion((model->exp+i),lmax,type,model->ivec,
		      nside,order,verbose);
d93 2
a94 4
    if(model->exp[i].tnplm != model->exp[0].tnplm){
      fprintf(stderr,"init_sh_model: tnplm mismatch\n");
      exit(-1);
    }
d100 1
a100 1
    MEMERROR("init_sh_model: z");
d110 1
a110 1
void free_sh_model(struct lms_model *model)
d115 1
a115 1
    free_expansion((model->exp+i),model->ivec);
d157 1
a157 1
void print_sh_model_coefficients(struct lms_model *model, 
a161 1
  CPREC value[2];
d163 2
a164 5
    if(!model->exp[i].spectral_init){
      fprintf(stderr,"print_sh_coefficients: error: coefficients not initialized expansion %i\n",
	      i+1);
      exit(-1);
    }
d166 4
a169 19
    /* print

    lmax i+1 z[i] nset shps expansion_type
    */
    fprintf(out,"%6i %6i %11g %6i %2i %2i ",
	    model->exp[i*model->shps].lmax,i+1,
	    model->z[i],model->nset,
	    model->shps,
	    model->exp[i*model->shps].type);
    switch(model->exp[i*model->shps].type){
    case RICK:
      break;
    case HEALPIX:
      break;
    default:
      exp_type_error("print_sh_coefficients",(model->exp+i*model->shps));
      break;
    }
    fprintf(out,"\n");		/* finish header line */
d171 1
a171 1
    print_sh_coefficients((model->exp+i*model->shps), 
d190 1
a190 1
void print_sh_model_spatial_basis(struct lms_model *model, 
d195 1
a195 1
    fprintf(stderr,"print_sh_model_spatial_basis: printing spatial basis for nset %i expansions\n",
d198 1
a198 1
    print_sh_spatial_basis((model->exp+i*model->shps),out,
d225 1
a225 1
void read_sh_model_spatial_data(struct lms_model *model, 
d234 1
a234 1
  fprintf(stderr,"read_sh_spatial_data: reading %i sets, expecting %s locations and %s data\n",
d241 1
a241 1
		 "read_sh_spatial_data");
d250 1
a250 1
	fprintf(stderr,"read_sh_spatial_data: error: set %i expansion %i out of %i: npoints: %i npoints(0): %i\n",
d282 1
a282 1
	  fprintf(stderr,"print_sh_spatial_basis: error: ordering %i undefined\n",
d293 1
a293 1
	exp_type_error("read_sh_spatial_data",(model->exp+i*model->shps));
d302 1
a302 1
	  fprintf(stderr,"read_sh_spatial_data: error: lon lat format: pixel %i: read error\n",
d311 1
a311 1
	  fprintf(stderr,"read_sh_spatial_data: error: lon lat z format: set %i: pixel %i: read error\n",
d323 1
a323 1
	  fprintf(stderr,"read_sh_spatial_data: error: scalar format: set %i: pixel %i: read error\n",
d335 1
a335 1
	  fprintf(stderr,"read_sh_spatial_data: error: velocity format: set %i: pixel %i: read error\n",
d350 1
a350 1
	fprintf(stderr,"read_sh_spatial_data: error: set: %i: pixel %i coordinate mismatch:\n",
d352 1
a352 1
	fprintf(stderr,"read_sh_spatial_data: orig: %g, %g file: %g, %g\n",
d359 1
a359 1
	fprintf(stderr,"read_sh_spatial_data: read set %3i, %6i points, avg type %i: %11g\n",
d376 1
a376 1
void compute_sh_model_spectral(struct lms_model *model,
d382 2
a383 4
  if(!model->spatial_init){
    fprintf(stderr,"compute_sh_model_spectral: error: spatial set not initialized\n");
    exit(-1);
  }
d386 1
a386 1
    fprintf(stderr,"compute_sh_model_spectral: error: ivec: %i nshp: %i\n",
d396 1
a396 1
      compute_sh_spectral((data+model->exp[i*model->shps+0].npoints), 
d402 1
a402 1
      compute_sh_spectral(data,zero,model->save_plm,&model->plm,
d407 1
a407 1
      compute_sh_spectral(data,zero,model->save_plm,&model->plm,
d418 1
a418 1
void compute_sh_model_spatial(struct lms_model *model,
d427 1
a427 1
    fprintf(stderr,"compute_sh_model_spatial: computing %i spatial points, type %i\n",
d429 1
a429 1
  my_svecrealloc(data,model->tnpoints,"compute_sh_spatial");
d432 1
a432 1
    fprintf(stderr,"compute_sh_model_spatial: error: ivec: %i nshp: %i\n",
d442 1
a442 1
      compute_sh_spatial((model->exp+i*model->shps+1), 
d447 1
a447 1
      compute_sh_spatial((model->exp+i*model->shps+0),
d452 1
a452 1
      compute_sh_spatial((model->exp+i*model->shps),zero,
d463 1
a463 1
void print_sh_model_spatial_data(struct lms_model *model,
d471 1
a471 1
    print_sh_spatial_data((model->exp+i*model->shps),
@
