head	1.10;
access;
symbols;
locks
	becker:1.10; strict;
comment	@ * @;


1.10
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.06.00.38.36;	author becker;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.31.00.01.25;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.30.23.52.04;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.02.00.14.44;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.01.01.25.28;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.23.01.06.56;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.21.01.16.31;	author becker;	state Exp;
branches;
next	;


desc
@@


1.10
log
@*** empty log message ***
@
text
@#include "hc.h"
/* 

solve the poloidal and toroidal part of a Hager & O'Connell type flow
computation



free_slip: TRUE/FALSE. if false, will either use the plate motions or no-slip,
           depending on how hc->pvel was initialized

solve_mode: solution mode, used for summing the solutions

iformat: flag that affects the poloidal solution routine
iformat <= 0: geoid kernel computation, 
              will use solution component -iformat-1
	   0: will use solution component 4 out of [0....5]
          >0 flow 

dens_fac_changed: has the density anomaly expansion changed since the last call to 
                  hc_solve?

plate_vel_changed: have the plate motion expansions changed since the last call to
                   hc_solve?

viscosity_or_layer_changed: has the viscosity structure or the layer spacing 
                            of density anomalies changed since the last call to
                            hc_solve?

input/output:
           sol: [3*nradp2] expansions holding radial poloidal and toroidal 
	            components. lmax of expansion has to be >= lmax(plates)
	        has to be initialized before calling this routine


*/

void hc_solve(struct hcs *hc, hc_boolean free_slip, 
	      int solve_mode,struct sh_lms *sol, 
	      hc_boolean dens_anom_changed,
	      hc_boolean plate_vel_changed,
	      hc_boolean viscosity_or_layer_changed,
	      hc_boolean verbose)
{
  int nsh_pol,nsh_tor=0;
    static int iformat = 1;	/* no geoid for now */
  double *tvec;
  static hc_boolean 
    tor_init = FALSE,		
    pol_init = FALSE,
    geoid_init = FALSE;
  if(!hc->initialized)
    HC_ERROR("hc_solve","hc structure not initialized");
  if(!free_slip&&(hc->pvel[0].lmax < hc->dens_anom[0].lmax)){
    fprintf(stderr,"hc_solve: error: plate expansion lmax (%i) has to be >= density lmax (%i)\n",
	    hc->pvel[0].lmax,hc->dens_anom[0].lmax);
    exit(-1);
  }
  if(sol[0].lmax < hc->pvel[0].lmax){
    fprintf(stderr,"hc_solve: error: solution lmax (%i) has to be >= plate velocitiy lmax (%i)\n",
	    sol[0].lmax,hc->pvel[0].lmax);
    exit(-1);
  }
  /* 
     POLOIDAL PART  
  */
  /* 
     initialize a bunch of expansions for the poloidal solution 
  */
  nsh_pol = 6 * (hc->nrad+2);	/* u[4] plus poten[2] */
  if((!pol_init)||(!hc->save_solution)){
    /* room for pol solution */
    sh_allocate_and_init(&hc->pol_sol,nsh_pol,
			 hc->dens_anom[0].lmax,hc->sh_type,
			 0,verbose);
  }
  if(iformat <= 0){
    /* make room for geoid solution */
    if((!geoid_init)||(!hc->save_solution)){
      sh_allocate_and_init(&hc->geoid,nsh_pol,hc->dens_anom[0].lmax,
			   hc->sh_type,0,verbose);
      geoid_init = TRUE;
    }
  }
  if((!hc->save_solution) || (!pol_init) || viscosity_or_layer_changed ||
     dens_anom_changed || ((!free_slip)&&(plate_vel_changed))){  
    /* 
       
    FIND POLOIDAL SOLUTION 

    if the density anomalies, the viscosity structure, or the plate
    velocities changed
    
    */
    hc_polsol(hc,hc->nrad,hc->r,hc->inho,hc->dfact,
	      viscosity_or_layer_changed,
	      hc->dens_anom,hc->compressible,
	      hc->npb,hc->rpb,hc->fpb,free_slip,
	      (hc->pvel+0),hc->pol_sol,
	      iformat,hc->geoid,hc->save_solution,
	      verbose);
    if(hc->print_pt_sol)
      hc_print_poloidal_solution(hc->pol_sol,hc,31,
				 HC_POLSOL_FILE,verbose);
  }
  if(!free_slip){
    /* 
       
       solve toroidal part only for no-slip surface boundary condition

    */
    if((!tor_init)||(!hc->save_solution)){
      nsh_tor = 2 * (hc->nrad+2);
      sh_allocate_and_init(&hc->tor_sol,nsh_tor,hc->pvel[1].lmax,
			   hc->sh_type,0,verbose);
    }
    if((!tor_init) || viscosity_or_layer_changed || plate_vel_changed || 
       (!hc->save_solution)){
      /* 
	 if we are not saving solutions, or the velocities or viscosities
	 have changed, we need to (re)compute the toroidal solution
      */
      /* make room for solution kernel */
      hc_vecalloc(&tvec,(hc->nrad+2)*(hc->pvel[1].lmax+1)*2,
		  "hc_solve");
      /* compute kernels, and assign kernel*pvel to tor_sol */
      hc_torsol(hc->nrad,hc->nvis,hc->pvel[1].lmax,hc->r,
		&hc->rvisc,&hc->visc,(hc->pvel+1),hc->tor_sol,tvec,
		verbose);
      if(hc->print_pt_sol)
	hc_print_toroidal_solution(tvec,hc->pvel[1].lmax,
				   hc,hc->pvel[1].lmax,HC_TORSOL_FILE,verbose);
      free(tvec);
    }
  }else{
    nsh_tor = 0;
  }
  switch(solve_mode){
  case HC_VEL:
    if(verbose)
      fprintf(stderr,"hc_solve: computing solution for velocities\n");
    break;
  case HC_STRESS:
    if(verbose)
      fprintf(stderr,"hc_solve: computing solution for stresses\n");
    break;
  case HC_GEOID:
    if(verbose)
      fprintf(stderr,"hc_solve: computing solution for geoid\n");
    HC_ERROR("hc_solve","geoid not implemented yet");
    break;
  default:
    fprintf(stderr,"hc_solve: error: solution mode %i undefined\n",
	    solve_mode);
    exit(-1);
    break;
  }
  /* 

     sum up the poloidal and torodial solutions and set the spectral
     init flag to true for solution expansion
     
  */
  hc_sum(hc,hc->nrad,hc->pol_sol,hc->tor_sol,solve_mode,free_slip,sol,
	 verbose);
  /* 
     free temporary arrays
  */
  if(!hc->save_solution){
    /* 
       POLOIDAL SOLUTION related expansions, those are not saved as they
       change with density anomalies and plate motions
    */
    sh_free_expansion(hc->pol_sol,nsh_pol);
    if(iformat <= 0){		/* 
				   geoid 
				*/
      sh_free_expansion(hc->geoid,nsh_pol);
      geoid_init = TRUE;
    }
    /* 
       toroidal, maybe save those, since they only depend on plate velocities
       and viscosities 
    */
    if(!free_slip)
      sh_free_expansion(hc->tor_sol,nsh_tor);
  }
  pol_init = TRUE;
  tor_init = TRUE;
  hc->spectral_solution_computed = TRUE;
}
/* 
   
computes the radial, poloidal, and toroidal solution expansions 
as sol[3*nradp2] for each layer

input:

pol_sol[6*nradp2]: y1...y6    (six) poloidal solutions for each layer
tor_sol[2*nradp2]: y9 and y10 (two) toroidal solutions for each layer

*/
void hc_sum(struct hcs *hc,
	    int nrad,struct sh_lms *pol_sol, struct sh_lms *tor_sol, 
	    int solve_mode,hc_boolean free_slip, 
	    struct sh_lms *sol, 
	    hc_boolean verbose)
{
  int itchoose,irchoose,ipchoose; /* indices for which solutions to use */
  int i,j,i3,i6,nradp2;
  if(sol[0].lmax > hc->lfac_init)
    hc_init_l_factors(hc,sol[0].lmax);
  nradp2 = nrad + 2;
  /* 
     pick the right components for the radial, poloidal, and toroidal
     solution
     
  */
  if (solve_mode == HC_VEL){
    //
    //    velocity output requested 
    //
    irchoose = 0; // y1 for radial
    ipchoose = 1; // y2 for poloidal
    itchoose = 0; // y9 for toroidal
  }else{
    //
    //    srr srt srp stress output requested 
    //
    irchoose = 2;// y3  for radial
    ipchoose = 3;// y4  for poloidal
    itchoose = 1;// y10 for toroidal 
  }
  for(i=i3=i6=0;i < nradp2;i++,i3+=3,i6+=6){
    /* 
       radial part 
    */
    sh_aexp_equals_bexp_coeff((sol+i3+0),(pol_sol+i6+irchoose));
    /* 
       poloidal part, need to scale with sqrt(l(l+1))
    */
    sh_aexp_equals_bexp_coeff((sol+i3+1),(pol_sol+i6+ipchoose));
    sh_scale_expansion_l_factor((sol+i3+1),hc->lfac);
    for(j=0;j<3;j++)
      sol[i3+j].spectral_init = TRUE;
    if(!free_slip){
      /* 
	 toroidal part, need to scale with sqrt(l(l+1))
      */
      sh_aexp_equals_bexp_coeff((sol+i3+2),(tor_sol+i*2+itchoose));
      sh_scale_expansion_l_factor((sol+i3+2),hc->lfac);
    }else{
      /* no toroidal part for free-slip */
      sh_clear_alm((sol+i3+2));
    }
  } /* end layer loop */
}


/* 

given a spherical harmonic solution, compute the spatial 
corresponding solution

sol[nradp2 * 3 ]

data has to be initialized, eg. as NULL
*/
void hc_compute_sol_spatial(struct hcs *hc, struct sh_lms *sol_w,
			    float **sol_x, hc_boolean verbose)
{
  int i,i3,nradp2,np,np2,np3,os;
  static int ntype = 3;
  nradp2 = hc->nrad + 2;
  np = sol_w[0].npoints;
  np2 = np * 2;
  np3 = np2 + np;	/* 
			   number of points per spatial 
			   expansions for r, pol, tor
			*/
  /* allocate space for spatial solution*/
  hc_svecrealloc(sol_x,np3*nradp2,"sol_x");
  /* 
     compute the plm factors 
  */
  sh_compute_plm(sol_w,1,&hc->plm,verbose);
  for(i=i3=0;i < nradp2;i++,i3 += ntype){
    os = i*np3;
    /* radial component */
    sh_compute_spatial((sol_w+i3),0,TRUE,&hc->plm,
		       (*sol_x+os),verbose);
    os += np;
    /* poloidal/toroidal component */
    sh_compute_spatial((sol_w+i3+1),1,TRUE,&hc->plm,
		       (*sol_x+os),verbose);
  }
  hc->spatial_solution_computed = TRUE;
}
@


1.9
log
@*** empty log message ***
@
text
@d45 1
a45 1
  int nsh_pol,nsh_tor;
a48 1
    was_called = FALSE,
d272 1
a272 2
  int i,i3,j,nradp2,np,np2,np3,os;
  float *data;
@


1.8
log
@*** empty log message ***
@
text
@d39 1
a39 1
	      int solve_mode,struct lms *sol, 
d205 1
a205 1
	    int nrad,struct lms *pol_sol, struct lms *tor_sol, 
d207 1
a207 1
	    struct lms *sol, 
d270 1
a270 1
void hc_compute_sol_spatial(struct hcs *hc, struct lms *sol_w,
@


1.7
log
@*** empty log message ***
@
text
@d38 2
a39 2
void hc_solve(struct hcs *hc, hc_boolean free_slip, int solve_mode,
	      struct lms *sol, 
d45 1
a45 1
  int i,nsh_pol,nsh_tor;
d47 1
d52 1
a52 4
    geoid_init = FALSE,
    print_ptsol = FALSE; 		/* print the poloidal and
					   toroidal solution vectors to
					   file */
d71 1
a71 2

  nsh_pol = 6 * (hc->nrad+2);
d73 4
a76 2
    sh_allocate_and_init(&hc->pol_sol,nsh_pol,hc->dens_anom[0].lmax,
			 hc->sh_type,0,verbose);
d78 2
a79 1
  if(iformat <= 0){/* make room for geoid solution */
d90 4
a93 2
    find poloidal solution if the density anomalies, the viscosity
    structure, or the plate velocities changed
d99 7
a105 2
	      hc->npb,hc->rpb,hc->fpb,free_slip,(hc->pvel+0),hc->pol_sol,
	      iformat,hc->geoid,hc->save_solution,print_ptsol,verbose);
d119 3
a121 2
       (!hc->save_solution))
      /* if we are not saving solutions, or the velocities or viscosities
d124 6
a129 2
      hc_torsol(hc->nrad,hc->nvis,hc->pvel[1].lmax,hc->r,&hc->rvisc,
		&hc->visc,(hc->pvel+1),hc->tor_sol,print_ptsol,
d131 5
d175 1
a175 2
    for(i=0;i < nsh_pol;i++)
      sh_free_expansion((hc->pol_sol+i));
d179 1
a179 2
      for(i=0;i < nsh_pol;i++)
	sh_free_expansion((hc->geoid+i));
d187 1
a187 2
      for(i=0;i < nsh_tor;i++)
	sh_free_expansion((hc->tor_sol+i));
d290 1
d293 2
a294 1
		       (*sol_x+(os=i*np3)),verbose);
d297 1
a297 1
		       (*sol_x+os+np),verbose);
@


1.6
log
@*** empty log message ***
@
text
@d143 4
a146 1
     sum up the poloidal and torodial solutions
d148 2
a149 1
  hc_sum(hc,hc->nrad,hc->pol_sol,hc->tor_sol,solve_mode,free_slip,sol,verbose);
d177 1
d197 1
a197 1
  int i,i3,i6,nradp2;
d231 2
d246 39
@


1.5
log
@*** empty log message ***
@
text
@a238 41
/* 

given a spherical harmonic solution, compute the spatial 
corresponding solution

sol[nradp2 * 3 ]

data has to be initialized, eg. as NULL
*/
void hc_compute_sol_spatial(struct hcs *hc, struct lms *sol_w,
			    CPREC **sol_x, my_boolean verbose)
{
  int i,j,nradp2,np,np2,np3,os;
  float *data = NULL;
  nradp2 = hc->nrad + 2;
  np = sol_w[0].npoints;
  np2 = np * 2;
  np3 = np2 + np;	/* 
			   number of points per spatial 
			   expansions for r, pol, tor
			*/
  /* allocate space for spatial soltuion*/
  hc_vecrealloc(sol_x,np3*nradp2,"sol_x");
  /* 
     compute the plm factors 
  */
  sh_compute_plm(sol_w,1,&hc->plm,verbose);
  for(i=0;i < nradp2;i++){
    /* radial component */
    sh_compute_spatial((sol_w+i*3),0,TRUE,&hc->plm,
		       data,verbose);
    for(os = i * np3, j=0;j < np;j++)
      *(*sol_x+os+j) = data[j];
    /* poloidal/toroidal component */
    sh_compute_spatial((sol_w+i*3+1),1,TRUE,&hc->plm,
		       data,verbose);
    for(os = i * np3 + np, j=0;j < np2;j++)
      *(*sol_x+os+j) = data[j];
  }
  free(data);
}
@


1.4
log
@*** empty log message ***
@
text
@d187 2
a188 1
	    int solve_mode,hc_boolean free_slip, struct lms *sol, 
d197 3
a199 1
     pick the right components for the solution
d238 42
@


1.3
log
@*** empty log message ***
@
text
@d20 10
d35 1
d38 6
a43 2
void hc_solve(struct hcs *hc, my_boolean free_slip, int solve_mode,
	      struct lms *sol, my_boolean verbose)
d46 2
a47 3
  struct lms *pol_sol,*tor_sol,*geoid;
  static int iformat = 1;	/* no geoid for now */
  static my_boolean 
d49 6
a54 3
    dens_fac_changed = TRUE, 	/* set to TRUE, if anomalies should be incorporated 
				   into poloidal solution anew */
    print_psol = TRUE; 		/* print the poloidal solution vector to file */
d56 1
a56 1
    MY_ERROR("hc_solve","hc structure not initialized");
d73 1
d75 25
a99 13
  sh_allocate_and_init(&pol_sol,nsh_pol,hc->dens_anom[0].lmax,hc->sh_type,0,verbose);
  if(iformat <= 0)/* make room for geoid solution */
    sh_allocate_and_init(&geoid,nsh_pol,hc->dens_anom[0].lmax,hc->sh_type,0,verbose);
  /* 

     find poloidal solution 

  */
  hc_polsol(hc,hc->nrad,hc->r,hc->nvis,hc->visc,hc->rv,
	    hc->inho,hc->dfact,dens_fac_changed, 
	    hc->rden,hc->dens_anom,hc->compressible,
	    hc->npb,hc->rpb,hc->fpb,free_slip,(hc->pvel+0),pol_sol,
	    iformat,geoid,hc->save_prop,print_psol,verbose);
d102 2
a103 2

       solve toroidal part 
d106 13
a118 4
    nsh_tor = 2 * (hc->nrad+2);
    sh_allocate_and_init(&tor_sol,nsh_tor,hc->pvel[1].lmax,hc->sh_type,0,verbose);
    hc_torsol(hc->nrad,hc->nvis,hc->pvel[1].lmax,hc->r,&hc->rv,
	      &hc->visc,(hc->pvel+1),tor_sol,verbose);
a121 3
  /* 
     sum solutions
  */
d134 1
a134 1
    MY_ERROR("hc_solve","geoid not implemented yet");
d142 4
a145 2
  /* actually call the summing routine */
  hc_sum(hc,hc->nrad,pol_sol,tor_sol,solve_mode,free_slip,sol,verbose);
d149 5
a153 4
  /* poloidal solution expansions */
  for(i=0;i < nsh_pol;i++)
    sh_free_expansion((pol_sol+i));
  if(iformat <= 0)		/* geoid */
d155 18
a172 5
      sh_free_expansion((geoid+i));
  /* toroidal */
  if(!free_slip)
    for(i=0;i < nsh_tor;i++)
      sh_free_expansion((tor_sol+i));
d187 2
a188 2
	    int solve_mode,my_boolean free_slip, struct lms *sol, 
	    my_boolean verbose)
@


1.2
log
@*** empty log message ***
@
text
@d33 5
a37 2
  static my_boolean was_called = FALSE,
    dens_fac_changed = TRUE; 
d40 1
a40 1
  if(hc->pvel[0].lmax < hc->dens_anom[0].lmax){
d69 1
a69 1
	    iformat,geoid,hc->save_prop,verbose);
d77 2
a78 2
    sh_allocate_and_init(&tor_sol,nsh_tor,hc->pvel[0].lmax,hc->sh_type,0,verbose);
    hc_torsol(hc->nrad,hc->nvis,hc->pvel[0].lmax,hc->r,&hc->rv,
d88 3
d92 2
a93 1
    hc_sum(hc->nrad,pol_sol,tor_sol,solve_mode,free_slip,sol,verbose);
d96 2
d106 2
a107 1

d118 3
a120 2
  for(i=0;i < nsh_tor;i++)
    sh_free_expansion((tor_sol+i));
d133 2
a134 1
void hc_sum(int nrad,struct lms *pol_sol, struct lms *tor_sol, 
d140 2
d167 1
a167 1
       poloidal part
d170 1
d173 1
a173 1
	 toroidal part 
d176 1
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
  int nout,i,nsh_pol,nsh_tor;
d58 1
d60 1
d65 1
a65 2
	    hc->npb,hc->rpb,hc->fpb,&nout,
	    free_slip,(hc->pvel+0),pol_sol,
a66 5
  if(nout != hc->nrad+2){
    fprintf(stderr,"hc_solve: error: nout: %i nrad+2: %i\n",
	    nout,hc->nrad+2);
    exit(-1);
  }
d69 1
d71 1
d73 1
a73 1
    nsh_tor = 2*(hc->nrad+2);
d76 1
a76 1
	      &hc->visc,(hc->pvel+1),tor_sol);
d127 1
a127 1
  int layer,nradp2,os1,os2;
d147 1
a147 1
  for(os1=os2=layer=0;layer < nradp2;layer++,os1+=6,os2+=3){
d151 1
a151 1
    sh_aexp_equals_bexp_coeff((sol+os2+0),(pol_sol+os1+irchoose));
d155 1
a155 1
    sh_aexp_equals_bexp_coeff((sol+os2+1),(pol_sol+os1+ipchoose));
d160 1
a160 1
      sh_aexp_equals_bexp_coeff((sol+os2+2),(tor_sol+os1+itchoose));
d163 1
a163 1
      sh_clear_alm((sol+os2+2));
@
