head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2006.03.20.05.32.48;	author becker;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.30.23.52.04;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.23.01.06.56;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.21.01.16.31;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.11.23.51.23;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.11.23.43.19;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.11.22.32.35;	author becker;	state Exp;
branches;
next	;


desc
@@


1.10
log
@*** empty log message ***
@
text
@
/* 

small matrix inversion routines used by hc_polsol of H & C code


lifted from numerical recipes, but changed the matrix addressing
a[0...2][0...2]

this was moderately well tested.


$Id: hc_matrix.c,v 1.9 2006/01/22 01:11:34 becker Exp becker $

*/

#ifdef COMPILE_TEST
/* 
   test routine 
*/
#include <stdio.h>
#include <math.h>
#define HC_PREC double
#define FALSE 0
#define HC_EPS_PREC 5e-15
void hc_ludcmp_3x3(HC_PREC [3][3],int *);
void hc_lubksb_3x3(HC_PREC [3][3],int *,HC_PREC *);
void main(void){
  HC_PREC amat[3][3],bvec[3];int i,j,indx[3];
  char fstring[10];
  /* read in A from stdin */
  for(i=0;i<3;i++)
    for(j=0;j<3;j++)
    fscanf(stdin,"%lf",&amat[i][j]);
  /* read in x from stdin */
  for(i=0;i<3;i++)
    fscanf(stdin,"%lf",&bvec[i]);
  /* solve A x = b, where b will be modified  */
  hc_ludcmp_3x3(amat,indx);hc_lubksb_3x3(amat,indx,bvec);
  for(i=0;i<3;i++)fprintf(stdout,"%g\n",bvec[i]);
}
#else
/* 

   normal compilation 

*/
#include "hc.h"
#endif

#define NR_TINY 1.0e-20;

void hc_ludcmp_3x3(HC_PREC a[3][3],int *indx)
{
  int i,imax=0,j,k;
  HC_PREC big,dum,sum,temp;
  HC_PREC vv[3];
  
  for (i=0;i < 3;i++) {
    big=0.0;
    for (j=0;j < 3;j++)
      if ((temp = fabs(a[i][j])) > big) 
	big=temp;
    if (fabs(big) < HC_EPS_PREC) {
      fprintf(stderr,"hc_ludcmp_3x3: singular matrix in routine, big: %g\n",
	      big);
      //hc_print_3x3(a,stderr);
      for(j=0;j<3;j++)
	fprintf(stderr,"%g %g %g\n",a[j][0],a[j][1],a[j][2]);
      exit(-1);
    }
    vv[i]=1.0/big;
  }
  for (j=0;j < 3;j++) {
    for (i=0;i < j;i++) {
      sum = a[i][j];
      for (k=0;k < i;k++) 
	sum -= a[i][k] * a[k][j];
      a[i][j]=sum;
    }
    big=0.0;
    for (i=j;i < 3;i++) {
      sum=a[i][j];
      for (k=0;k < j;k++)
	sum -= a[i][k] * a[k][j];
      a[i][j]=sum;
      if ( (dum = vv[i]*fabs(sum)) >= big) {
	big=dum;
	imax=i;
      }
    }
    if (j != imax) {
      for (k=0;k < 3;k++) {
	dum = a[imax][k];
	a[imax][k]=a[j][k];
	a[j][k]=dum;
      }
      vv[imax]=vv[j];
    }
    indx[j]=imax;
    if (fabs(a[j][j]) < HC_EPS_PREC) 
      a[j][j] = NR_TINY;
    if (j != 2) {
      dum=1.0/(a[j][j]);
      for (i=j+1;i < 3;i++) 
	a[i][j] *= dum;
    }
  }
}
#undef NR_TINY
void hc_lubksb_3x3(HC_PREC a[3][3], int *indx, HC_PREC *b)
{
  int i,ii=0,ip,j;
  HC_PREC sum;
  for (i=0;i < 3;i++) {
    ip = indx[i];
    sum = b[ip];
    b[ip]=b[i];
    if (ii)
      for (j=ii-1;j <= i-1;j++) 
	sum -= a[i][j]*b[j];
    else if (fabs(sum)>HC_EPS_PREC) 
      ii = i+1;
    b[i]=sum;
  }
  for (i=2;i>=0;i--) {
    sum=b[i];
    for (j=i+1;j < 3;j++) 
      sum -= a[i][j]*b[j];
    b[i] = sum/a[i][i];
  }
}

@


1.9
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.8 2004/12/20 05:18:12 becker Exp becker $
d24 2
d29 1
a29 1
  HC_PREC amat[3][3],bvec[3]={7.,-1,5.};int i,j,indx[3];
a30 1
  hc_get_flt_frmt_string(fstring,1,FALSE);
d32 6
a37 2
  for(i=0;i<3;i++)for(j=0;j<3;j++)
    fscanf(stdin,fstring,&amat[i][j]);
d64 1
a64 1
    if (fabs(big) > HC_EPS_PREC) {
d67 3
a69 1
      hc_print_3x3(a,stderr);
d101 1
a101 1
    if (fabs(a[j][j]) > HC_EPS_PREC) 
d111 1
a111 1
void hc_lubksb_3x3(HC_PREC a[3][3],int *indx,HC_PREC *b)
d122 1
a122 1
    else if (sum) 
@


1.8
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.7 2004/12/01 01:25:35 becker Exp becker $
d50 1
a50 1
  int i,imax,j,k;
d59 1
a59 1
    if (big == 0.0) {
d94 1
a94 1
    if (a[j][j] == 0.0) 
@


1.7
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.6 2004/07/30 23:52:04 becker Exp becker $
d23 3
a25 3
#define HC_CPREC double
void hc_ludcmp_3x3(HC_CPREC [3][3],int *);
void hc_lubksb_3x3(HC_CPREC [3][3],int *,HC_CPREC *);
d27 1
a27 1
  HC_CPREC amat[3][3],bvec[3]={7.,-1,5.};int i,j,indx[3];
d48 1
a48 1
void hc_ludcmp_3x3(HC_CPREC a[3][3],int *indx)
d51 2
a52 2
  HC_CPREC big,dum,sum,temp;
  HC_CPREC vv[3];
d104 1
a104 1
void hc_lubksb_3x3(HC_CPREC a[3][3],int *indx,HC_CPREC *b)
d107 1
a107 1
  HC_CPREC sum;
@


1.6
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.5 2004/06/23 01:06:56 becker Exp becker $
d23 3
a25 3
#define CPREC double
void hc_ludcmp_3x3(CPREC [3][3],int *);
void hc_lubksb_3x3(CPREC [3][3],int *,CPREC *);
d27 1
a27 1
  CPREC amat[3][3],bvec[3]={7.,-1,5.};int i,j,indx[3];
d48 1
a48 1
void hc_ludcmp_3x3(CPREC a[3][3],int *indx)
d51 2
a52 2
  CPREC big,dum,sum,temp;
  CPREC vv[3];
d104 1
a104 1
void hc_lubksb_3x3(CPREC a[3][3],int *indx,CPREC *b)
d107 1
a107 1
  CPREC sum;
@


1.5
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.4 2004/06/21 01:16:31 becker Exp becker $
d28 2
d31 2
a32 1
  for(i=0;i<3;i++)for(j=0;j<3;j++)fscanf(stdin,"%lf",&amat[i][j]);
@


1.4
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.3 2004/06/11 23:51:23 becker Exp becker $
d26 2
a27 5

void main(void)
{
  CPREC amat[3][3],bvec[3]={7.,-1,5.};
  int i,j,indx[3];
d29 1
a29 3
  for(i=0;i<3;i++)
    for(j=0;j<3;j++)
      fscanf(stdin,"%lf",&amat[i][j]);
d31 2
a32 4
  hc_ludcmp_3x3(amat,indx);
  hc_lubksb_3x3(amat,indx,bvec);
  for(i=0;i<3;i++)
    fprintf(stdout,"%g\n",bvec[i]);
d35 5
a39 1
/* normal compilation */
d57 3
a59 1
      fprintf(stderr,"hc_ludcmp_3x3: singular matrix in routine\n");
@


1.3
log
@*** empty log message ***
@
text
@d4 1
a4 1
small matrix inversion routines used by densub of H & C code
d13 1
a13 1
$Id: hc_matrix.c,v 1.2 2004/06/11 23:43:19 becker Exp becker $
d43 1
a43 1
#include "hcexp.h"
@


1.2
log
@*** empty log message ***
@
text
@d13 1
a13 1
$Id: hc_matrix.c,v 1.1 2004/06/11 22:32:35 becker Exp becker $
d29 1
a29 1
  CPREC amat[3][3],bvec[3]={1.,2.,3.};
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#include "hcexp.h"
d10 2
d13 3
a15 1
$Id$
d17 3
d21 24
d48 1
a48 1
void hc_ludcmp_3x3(CPREC a[3][3],int *indx, CPREC *d)
a50 1
  static int n = 3;	/* 3 x 3 matrix */
d54 1
a54 2
  *d=1.0;
  for (i=0;i<n;i++) {
d56 1
a56 1
    for (j=0;j<n;j++)
d65 2
a66 2
  for (j=0;j<n;j++) {
    for (i=0;i<j;i++) {
d68 1
a68 1
      for (k=0;k<i;k++) 
d73 1
a73 1
    for (i=j;i<n;i++) {
d75 1
a75 1
      for (k=0;k<j;k++)
d84 1
a84 1
      for (k=0;k<n;k++) {
a88 1
      *d = -(*d);
d93 2
a94 2
      a[j][j] = TINY;
    if (j != n) {
d96 1
a96 1
      for (i=j+1;i<n;i++) 
d106 1
a106 2
  static int n = 3;
  for (i=0;i<n;i++) {
d111 1
a111 1
      for (j=ii;j<i-1;j++) 
d114 1
a114 1
      ii=i;
d117 1
a117 1
  for (i=n-1;i>=0;i--) {
d119 1
a119 1
    for (j=i+1;j<n;j++) 
d121 1
a121 1
    b[i]=sum/a[i][i];
@
