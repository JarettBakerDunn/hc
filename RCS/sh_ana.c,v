head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2006.01.22.01.11.34;	author becker;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.20.05.18.12;	author becker;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.20.05.09.42;	author becker;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.01.01.25.35;	author becker;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.24.02.09.00;	author becker;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.00.38.36;	author becker;	state Exp;
branches;
next	;


desc
@@


1.6
log
@*** empty log message ***
@
text
@#include "hc.h"

/* 

read in data in lon lat z format, spaced as required by the particular
type of spherical harmonic expansion desired and performs a spherical
harmonics analysis. input spatial data is read from stdin, output
coefficients in Dahlen and Tromp normalization to stdout

Thorsten Becker (twb@@usc.edu)


usage: cat data.lonlatz | sh_ana l_max ivec

       l_max: max order of expansion. if negative, will print out the spatial 
              locations needed on input
       
       ivec:  0: expand scalar field
              1: expand vector field

where data.lonlatz has the data at the required locations as put out by sh_ana -lmax

$Id: sh_ana.c,v 1.5 2004/12/20 05:18:12 becker Exp becker $

*/

int main(int argc, char **argv)
{
  int type = SH_RICK,lmax,shps, nset=1,ivec=0,ilayer=0;
  struct sh_lms *exp;
  hc_boolean verbose = TRUE, use_3d = FALSE, short_format = FALSE,
    binary = FALSE, print_spatial_base = FALSE;
  float *data, zlabel = 0,*flt_dummy;
  double *dbl_dummy;
  HC_PREC fac[3] = {1.,1.,1.};

  /* 
     command line parameters
  */
  if(argc > 1){
    if((strcmp(argv[1],"-h")==0)||(strcmp(argv[1],"--help")==0)||(strcmp(argv[1],"-help")==0))
      argc = -1000;
    else{			/* max order of expansion */
      sscanf(argv[1],"%i",&lmax);
      if(lmax < 0){
	print_spatial_base = TRUE;
	lmax = -lmax;
      }
    }
  }
  if(argc > 2)
    sscanf(argv[2],"%i",&ivec);
  if(argc > 3)
    sscanf(argv[3],"%i",&type);
  if((argc > 4)||(argc<=1)){
    fprintf(stderr,"usage: %s l_max [ivec, %i] [type, %i]\n",
	    argv[0],ivec,type);
    fprintf(stderr,"       l_max: max order of expansion. if negative, will print out the spatial\n");
    fprintf(stderr,"                 locations needed on input\n");
    fprintf(stderr,"              for Rick, lmax needs to be 2**n-1\n\n");
    fprintf(stderr,"       ivec:  0: expand scalar field (input: lon lat scalar)\n");
    fprintf(stderr,"              1: expand vector field (input: lon lat v_t v_p\n\n");
    fprintf(stderr,"       type:  %i: use Healpix's routines\n",SH_HEALPIX);
    fprintf(stderr,"              %i: use Rick's routines\n",SH_RICK);
    exit(-1);
  }
  if(print_spatial_base)
    fprintf(stderr,"%s: printing spatial base for lmax: %i\n",
	    argv[0],lmax);
  else
    fprintf(stderr,"%s: expanding to lmax: %i, expecting %s\n",
	    argv[0],lmax,(ivec)?("lon lat vt vp"):("lon lat x"));
  /* 
     select numbers of expansions, scalar or pol/tor for vector field
  */
  shps = (ivec)?(2):(1);
  /* intialize expansion first */
  sh_allocate_and_init(&exp,shps*nset,lmax,type,ivec,verbose);
  /* make room for data */
  hc_svecalloc(&data,shps * exp->npoints,"sh_ana");
  if(print_spatial_base){
    /* 
       print out spatial basis 
    */
    sh_compute_spatial_basis(exp,stdout,use_3d,zlabel,&flt_dummy,0,verbose);
  }else{
    /* 
       perform spherical harmonic analysis
    */
    /* read in data from stdin */
    sh_read_spatial_data(exp,stdin,use_3d,shps,data,&zlabel);
    /* 
       perform spherical harmonic expansion 
    */
    sh_compute_spectral(data,ivec,FALSE,&dbl_dummy,
			exp,verbose);
    /* print parameters of expansion */
    sh_print_parameters(exp,shps,ilayer,nset,zlabel,
			stdout,short_format,binary,
			verbose);
    /* print coefficients */
    sh_print_coefficients(exp,shps,stdout,fac,binary, 
			  verbose);
  }
  fprintf(stderr,"%s: printing to stdout, done\n",argv[0]);
  free(exp);free(data);
  return 0;
}
@


1.5
log
@*** empty log message ***
@
text
@d23 1
a23 1
$Id: sh_ana.c,v 1.4 2004/12/20 05:09:42 becker Exp becker $
d59 2
a60 1
    fprintf(stderr,"                 locations needed on input\n\n");
d105 1
@


1.4
log
@*** empty log message ***
@
text
@d23 1
a23 1
$Id: sh_ana.c,v 1.3 2004/12/01 01:25:35 becker Exp becker $
d29 1
a29 1
  int type = SH_RICK,lmax,shps, nset=1,ivec=0,i,ilayer=0;
d35 1
a35 1
  HC_CPREC fac[3] = {1.,1.,1.};
@


1.3
log
@*** empty log message ***
@
text
@d23 1
a23 1
$Id: sh_ana.c,v 1.2 2004/11/24 02:09:00 becker Exp becker $
d30 1
a30 1
  struct lms *exp;
@


1.2
log
@*** empty log message ***
@
text
@d23 1
a23 1
$Id: sh_ana.c,v 1.1 2004/08/06 00:38:36 becker Exp becker $
d35 1
a35 1
  CPREC fac[3] = {1.,1.,1.};
@


1.1
log
@Initial revision
@
text
@a0 3
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
d10 4
d15 5
a19 1
Thorsten Becker (twb@@usc.edu)
d21 1
d23 1
a23 1
$Id: sh_test.c,v 1.3 2004/07/02 00:14:44 becker Exp $
d29 5
a33 4
  int type=SH_SH_RICK,lmax,shps,ilayer,nset,ivec,i;
  hc_boolean verbose = TRUE, short_format = FALSE ,binary = FALSE;
  float *data;
  CPREC fac[3] = {1.,1.,1.},zlabel;
d35 1
a35 2
  struct lms *exp;
  
d37 28
a64 13
  
  while(sh_read_parameters(&type,&lmax,&shps,&ilayer,&nset,
			   &zlabel,&ivec,stdin,short_format,
			   binary,verbose)){
    /* input and init */
    sh_allocate_and_init(&exp,shps,lmax, type,ivec,verbose);
    sh_read_coefficients(exp,shps,stdin,binary,fac,verbose);
    /* expansion */
    hc_svecalloc(&data,exp[0].npoints * shps,"sh_shsyn");
    sh_compute_spatial(exp,ivec,FALSE,&dbl_dummy,data,verbose);
    /* output */
    sh_print_spatial_data(exp,shps,data,(nset>1)?(TRUE):(FALSE),zlabel,stdout);
    free(exp);free(data);
d66 39
a104 1

@
